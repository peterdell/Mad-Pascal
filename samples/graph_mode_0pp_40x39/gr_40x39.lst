mads 2.1.0 build 8 (23 Dec 19)
Source: gr_40x39.a65
     1 				; ------------------------------------------------------------
     2 				; Mad Pascal Compiler version 1.6.4 [2020/06/12] for 6502
     3 				; ------------------------------------------------------------
     4
     5 = 0010			STACKWIDTH	= 16
     6 = 2000			CODEORIGIN	= $2000
     7
     8 = 0001			TRUE		= 1
     9 = 0000			FALSE		= 0
    10
    11 				; ------------------------------------------------------------
    12
    13 					org $80
    14
    15 = 0080			fxptr	.ds 2						; VBXE pointer
    16 = 0082			psptr	.ds 2						; PROGRAMSTACK Pointer
    17
    18 = 0084			eax	.ds 4						;8 bytes (aex + edx) -> divREAL
    19 = 0088			edx	.ds 4
    20 = 008C			ecx	.ds 4
    21 = 0090			bp	.ds 2
    22 = 0092			bp2	.ds 2
    23
    24 				TMP
    25 				ztmp
    26 = 0094			ztmp8	.ds 1
    27 = 0095			ztmp9	.ds 1
    28 = 0096			ztmp10	.ds 1
    29 = 0097			ztmp11	.ds 1
    30
    31 = 0098			STACKORIGIN	.ds STACKWIDTH*4
    32 				zpend
    33
    34 				; ------------------------------------------------------------
    35
    36 = 0084			ax	= eax
    37 = 0084			al	= eax
    38 = 0085			ah	= eax+1
    39
    40 = 008C			cx	= ecx
    41 = 008C			cl	= ecx
    42 = 008D			ch	= ecx+1
    43
    44 = 0088			dx	= edx
    45 = 0088			dl	= edx
    46 = 0089			dh	= edx+1
    47
    48 					org eax
    49
    50 = 0084			FP1MAN0	.ds 1
    51 = 0085			FP1MAN1	.ds 1
    52 = 0086			FP1MAN2	.ds 1
    53 = 0087			FP1MAN3	.ds 1
    54
    55 					org ztmp8
    56
    57 = 0094			FP1SGN	.ds 1
    58 = 0095			FP1EXP	.ds 1
    59
    60 					org edx
    61
    62 = 0088			FP2MAN0	.ds 1
    63 = 0089			FP2MAN1	.ds 1
    64
    65 = 008A			FP2MAN2	.ds 1
    66 = 008B			FP2MAN3	.ds 1
    67
    68 					org ztmp10
    69
    70 = 0096			FP2SGN	.ds 1
    71 = 0097			FP2EXP	.ds 1
    72
    73 					org ecx
    74
    75 = 008C			FPMAN0	.ds 1
    76 = 008D			FPMAN1	.ds 1
    77 = 008E			FPMAN2	.ds 1
    78 = 008F			FPMAN3	.ds 1
    79
    80 					org bp2
    81
    82 = 0092			FPSGN	.ds 1
    83 = 0093			FPEXP	.ds 1
    84
    85 					.ifdef MAIN.@DEFINES.S_VBXE
    86 					opt h-
    87 					ins 'atari\s_vbxe\sdxld2.obx'
    88 					opt h+
    89 					.endif
    90
    91 				.local	RESOURCE
    92 					icl 'atari\resource.asm'
Source: resource.asm
     1
  1133 					opt l+
    93 = 0000				?EXTDETECT = 0
    94 = 0000				?VBXDETECT = 0
    95
    96 2000				RCDATA 'f8x6.fnt' CHARSET_RAM_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: resource.asm]
     2 = 0400			len = .filesize('f8x6.fnt')
    28 					org main.CHARSET_RAM_ADDRESS
    30 FFFF> A000-A3FF> 00 00 + 	ins 'f8x6.fnt'
    32 					.print '$R RCDATA  ',main.CHARSET_RAM_ADDRESS,'..',*-1," 'f8x6.fnt'"
    32 				$R RCDATA  $A000..$A3FF 'f8x6.fnt'
Source: gr_40x39.a65
    97 				.endl
    98
    99 				; ------------------------------------------------------------
   100
   101 A400				org CODEORIGIN
   102
   103 2000				STATICDATA
Macro: STATICDATA [Source: gr_40x39.a65]
Source: gr_40x39.a65
   104
   105 				; ------------------------------------------------------------
   106
   107 2000			RTLIB
   108 2000				icl 'rtl6502.asm'
Source: rtl6502.asm
   366 					opt l+
   109
   110 				.print 'ZPAGE: ',fxptr,'..',zpend-1
   110 				ZPAGE: $0080..$00D7
   111
   112 				.print 'RTLIB: ',RTLIB,'..',*-1
   112 				RTLIB: $2000..$20DB
   113
   114 				; ------------------------------------------------------------
   115
   116 20DC			START
   117 20DC BA				tsx
   118 20DD 8E 8C 24			stx MAIN.@halt+1
   119
   120 					.ifdef fmulinit
   121 					fmulinit
   122 					eif
   123
   124 = 001B			VLEN	= VARDATASIZE-VARINITSIZE
   125 = 24A5			VADR	= DATAORIGIN+VARINITSIZE
   126
   127 					ift VADR > $BFFF
   128 					ert 'Invalid memory address range ',VADR
   129 					eli (VLEN>0) && (VLEN<=256)
   130 20E0 A2 E5			ldx #256-VLEN
   131 20E2 A9 00			lda #0
   132 20E4 9D C0 23 E8 D0 FA		sta:rne VADR+VLEN-256,x+
   133 					eli VLEN>0
   134 					@fill #VADR #VLEN #0
   135 					eif
   136
   137 					.ifdef MAIN.@DEFINES.ROMOFF
   138 					icl 'atari\romoff.asm'
   139 					.endif
   140
   141 20EA A9 C0 85 82 A9 24 + 	mwa #PROGRAMSTACK psptr
   142
   143 20F2 A2 0F			ldx #$0f					; DOS II+/D ParamStr
   144 20F4 BD 40 03 9D 8F 24 + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   145
   146 20FD E8				inx						; X = 0
   147 20FE 86 90			stx bp						; BP = 0
   148
   149 2100 8E 08 D2			stx audctl					; reset POKEY
   150 2103 A9 03			lda #3
   151 2105 8D 0F D2			sta skctl
   152
   153 2108 CA				dex						; X = 255
   154
   155 2109				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: gr_40x39.a65]
    15 2109 20 14 23			jsr MAIN.M0PP.@UnitInit
   156
   157 210C			.local	MAIN						; PROCEDURE
   158
   159 210C 4C 35 24			jmp l_0007
   160
   161 				; ------------------------------------------------------------
   162
   163 210F			.local	SYSTEM						; UNIT
   164
   165 				; ------------------------------------------------------------
   166
   167 = 0101			__PORTB_BANKS	= $0101
   168 = 0648			M_PI_2	= $0648
   169 = 0192			D_PI_2	= $0192
   170 = 0004			D_PI_180	= $04
   171 = 0000			MGTIA	= $00
   172 = 0080			MVBXE	= $80
   173 = 0000			VBXE_XDLADR	= $00
   174 = 0100			VBXE_BCBADR	= $0100
   175 = 1000			VBXE_MAPADR	= $1000
   176 = 5000			VBXE_OVRADR	= $5000
   177 = B000			VBXE_WINDOW	= $B000
   178 = 0000			IDLI	= $00
   179 = 0001			IVBL	= $01
   180 = 00FE			CH_DELCHR	= $FE
   181 = 009B			CH_ENTER	= $9B
   182 = 001B			CH_ESC	= $1B
   183 = 001C			CH_CURS_UP	= $1C
   184 = 001D			CH_CURS_DOWN	= $1D
   185 = 001E			CH_CURS_LEFT	= $1E
   186 = 001F			CH_CURS_RIGHT	= $1F
   187 = 007F			CH_TAB	= $7F
   188 = 009B			CH_EOL	= $9B
   189 = 007D			CH_CLR	= $7D
   190 = 00FD			CH_BELL	= $FD
   191 = 007E			CH_DEL	= $7E
   192 = 009C			CH_DELLINE	= $9C
   193 = 009D			CH_INSLINE	= $9D
   194 = 0000			COLOR_BLACK	= $00
   195 = 000E			COLOR_WHITE	= $0E
   196 = 0032			COLOR_RED	= $32
   197 = 0096			COLOR_CYAN	= $96
   198 = 0068			COLOR_VIOLET	= $68
   199 = 00C4			COLOR_GREEN	= $C4
   200 = 0074			COLOR_BLUE	= $74
   201 = 00EE			COLOR_YELLOW	= $EE
   202 = 0028			COLOR_ORANGE	= $28
   203 = 00E4			COLOR_BROWN	= $E4
   204 = 003C			COLOR_LIGHTRED	= $3C
   205 = 0004			COLOR_GRAY1	= $04
   206 = 0006			COLOR_GRAY2	= $06
   207 = 000A			COLOR_GRAY3	= $0A
   208 = 00CC			COLOR_LIGHTGREEN	= $CC
   209 = 007C			COLOR_LIGHTBLUE	= $7C
   210 = 0004			FMOPENREAD	= $04
   211 = 0008			FMOPENWRITE	= $08
   212 = 0009			FMOPENAPPEND	= $09
   213 = 000C			FMOPENREADWRITE	= $0C
   214 = 249F			SCREENWIDTH	= DATAORIGIN+$0000
   215 = 24A1			SCREENHEIGHT	= DATAORIGIN+$0002
   216 = 24A3			DATESEPARATOR	= DATAORIGIN+$0004
   217 = D014			TVSYSTEM	= $D014
   218 = 02C0			adr.PALETTE	= $02C0
   219 210F			.var PALETTE	= adr.PALETTE .word
   220 = D012			adr.HPALETTE	= $D012
   221 210F			.var HPALETTE	= adr.HPALETTE .word
   222 = 24A4			FILEMODE	= DATAORIGIN+$0005
   223 = 24A5			GRAPHMODE	= DATAORIGIN+$0006
   224 = 24A6			IORESULT	= DATAORIGIN+$0007
   225 = 24A7			EOLN	= DATAORIGIN+$0008
   226 = 24A8			RNDSEED	= DATAORIGIN+$0009
   227
   228 = 210F C0 02		PALETTE
   228 = 2111 12 D0		HPALETTE
   228 				.endl							; UNIT SYSTEM
   229
   230 				; ------------------------------------------------------------
   231
   232 2113			.local	ATARI						; UNIT
   233
   234 				; ------------------------------------------------------------
   235
   236 = 0012			RTCLOK	= $12
   237 = 004D			ATRACT	= $4D
   238 = 0052			LMARGIN	= $52
   239 = 0053			RMARGIN	= $53
   240 = 0054			ROWCRS	= $54
   241 = 0055			COLCRS	= $55
   242 = 0057			DINDEX	= $57
   243 = 0058			SAVMSC	= $58
   244 = 0062			PALNTS	= $62
   245 = 006A			RAMTOP	= $6A
   246 = 0200			VDSLST	= $0200
   247 = 0230			SDLSTL	= $0230
   248 = 0290			TXTROW	= $0290
   249 = 0291			TXTCOL	= $0291
   250 = 0293			TINDEX	= $0293
   251 = 0294			TXTMSC	= $0294
   252 = 022F			SDMCTL	= $022F
   253 = 026F			GPRIOR	= $026F
   254 = 02F0			CRSINH	= $02F0
   255 = 02F3			CHACT	= $02F3
   256 = 02F4			CHBAS	= $02F4
   257 = 02FC			CH	= $02FC
   258 = 02C0			PCOLR0	= $02C0
   259 = 02C1			PCOLR1	= $02C1
   260 = 02C2			PCOLR2	= $02C2
   261 = 02C3			PCOLR3	= $02C3
   262 = 02C4			COLOR0	= $02C4
   263 = 02C5			COLOR1	= $02C5
   264 = 02C6			COLOR2	= $02C6
   265 = 02C7			COLOR3	= $02C7
   266 = 02C8			COLOR4	= $02C8
   267 = 02C8			COLBAKS	= $02C8
   268 = D000			HPOSP0	= $D000
   269 = D001			HPOSP1	= $D001
   270 = D002			HPOSP2	= $D002
   271 = D003			HPOSP3	= $D003
   272 = D004			HPOSM0	= $D004
   273 = D005			HPOSM1	= $D005
   274 = D006			HPOSM2	= $D006
   275 = D007			HPOSM3	= $D007
   276 = D008			SIZEP0	= $D008
   277 = D009			SIZEP1	= $D009
   278 = D00A			SIZEP2	= $D00A
   279 = D00B			SIZEP3	= $D00B
   280 = D00C			SIZEM	= $D00C
   281 = D00D			GRAFP0	= $D00D
   282 = D00E			GRAFP1	= $D00E
   283 = D00F			GRAFP2	= $D00F
   284 = D010			GRAFP3	= $D010
   285 = D011			GRAFM	= $D011
   286 = D004			P0PF	= $D004
   287 = D014			PAL	= $D014
   288 = D012			COLPM0	= $D012
   289 = D013			COLPM1	= $D013
   290 = D014			COLPM2	= $D014
   291 = D015			COLPM3	= $D015
   292 = D016			COLPF0	= $D016
   293 = D017			COLPF1	= $D017
   294 = D018			COLPF2	= $D018
   295 = D019			COLPF3	= $D019
   296 = D01A			COLBK	= $D01A
   297 = D01B			PRIOR	= $D01B
   298 = D01D			GRACTL	= $D01D
   299 = D01E			HITCLR	= $D01E
   300 = D200			AUDF1	= $D200
   301 = D201			AUDC1	= $D201
   302 = D202			AUDF2	= $D202
   303 = D203			AUDC2	= $D203
   304 = D204			AUDF3	= $D204
   305 = D205			AUDC3	= $D205
   306 = D206			AUDF4	= $D206
   307 = D207			AUDC4	= $D207
   308 = D208			AUDCTL	= $D208
   309 = D20F			SKSTAT	= $D20F
   310 = D301			PORTB	= $D301
   311 = D400			DMACTL	= $D400
   312 = D401			CHACTL	= $D401
   313 = D402			DLISTL	= $D402
   314 = D404			HSCROL	= $D404
   315 = D405			VSCROL	= $D405
   316 = D407			PMBASE	= $D407
   317 = D409			CHBASE	= $D409
   318 = D40A			WSYNC	= $D40A
   319 = D40B			VCOUNT	= $D40B
   320 = D40C			PENH	= $D40C
   321 = D40D			PENV	= $D40D
   322 = D40E			NMIEN	= $D40E
   323
   324 				.endl							; UNIT ATARI
   325
   326 				; ------------------------------------------------------------
   327
   328 2113			.local	CRT						; UNIT
   329
   330 2113			.local	KEYPRESSED					; FUNCTION | ASSEMBLER
   331
   332 				; ---------------------  ASM Block 053  ---------------------
   333
   334 2113 A0 00			ldy #$00	; false
   335 2115 AD FC 02			lda kbcodes
   336 2118 C9 FF			cmp #$ff
   337 211A F0 01			beq skp
   338 211C C8				iny		; true
   339
   340 				;	sty kbcodes
   341
   342 211D 8C AB 24		skp	sty Result
   343
   344 2120			@exit
   345
   346 				; ------------------------------------------------------------
   347
   348 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   349 				; as Pointer
   350
   351 2120 E8				inx
   352 2121 AD AB 24 95 98		mva RESULT :STACKORIGIN,x
   353
   354 					.ifdef @new
   355 					lda <@VarData
   356 					sta :ztmp
   357 					lda >@VarData
   358 					ldy #@VarDataSize-1
   359 					jmp @FreeMem
   360 					eif
   361
   362 				; ------------------------------------------------------------
   363
   364 = 24AB			RESULT	= DATAORIGIN+$000C
   365
   366 = 24AB			@VarData	= RESULT
   367 = 0001			@VarDataSize	= 1
   368
   369 2126 60				rts						; ret
   370 				.endl
   371
   372 2127			.local	TEXTMODE					; PROCEDURE | ASSEMBLER
   373
   374 				; ------------------------------------------------------------
   375
   376 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   377 				; as Pointer
   378 2127 B5 98 8D AC 24		mva :STACKORIGIN,x MODE
   379 212C CA				dex
   380
   381 				; ---------------------  ASM Block 059  ---------------------
   382
   383 212D 8A 48			txa:pha
   384
   385 212F 20 00 20			@clrscr
   386
   387 2132 68 AA			pla:tax
   388
   389
   390 				; ------------------------------------------------------------
   391
   392 = 24AC			MODE	= DATAORIGIN+$000D
   393
   394 = 24AC			@VarData	= MODE
   395 = 0001			@VarDataSize	= 1
   396
   397 2134			@exit
   398 					.ifdef @new
   399 					lda <@VarData
   400 					sta :ztmp
   401 					lda >@VarData
   402 					ldy #@VarDataSize-1
   403 					jmp @FreeMem
   404 					eif
   405 2134 60				rts						; ret
   406 				.endl
   407
   408 				; ------------------------------------------------------------
   409
   410 = 24AA			TEXTATTR	= DATAORIGIN+$000B
   411 = D01F			CONSOL	= $D01F
   412 = 0000			CN_START_SELECT_OPTION	= $00
   413 = 0001			CN_SELECT_OPTION	= $01
   414 = 0002			CN_START_OPTION	= $02
   415 = 0003			CN_OPTION	= $03
   416 = 0004			CN_START_SELECT	= $04
   417 = 0005			CN_SELECT	= $05
   418 = 0006			CN_START	= $06
   419 = 0007			CN_NONE	= $07
   420 = 0000			BW40	= $00
   421 = 0001			CO40	= $01
   422 = 0002			BW80	= $02
   423 = 0003			CO80	= $03
   424 = 0007			MONO	= $07
   425 = 0001			C40	= $01
   426 = 0003			C80	= $03
   427 = 0000			BLACK	= $00
   428 = 0001			BLUE	= $01
   429 = 0002			GREEN	= $02
   430 = 0003			CYAN	= $03
   431 = 0004			RED	= $04
   432 = 0005			MAGENTA	= $05
   433 = 0006			BROWN	= $06
   434 = 0007			LIGHTGRAY	= $07
   435 = 0008			DARKGRAY	= $08
   436 = 0009			LIGHTBLUE	= $09
   437 = 000A			LIGHTGREEN	= $0A
   438 = 000B			LIGHTCYAN	= $0B
   439 = 000C			LIGHTRED	= $0C
   440 = 000D			LIGHTMAGENTA	= $0D
   441 = 000E			YELLOW	= $0E
   442 = 000F			WHITE	= $0F
   443 = 0080			BLINK	= $80
   444
   445 				.endl							; UNIT CRT
   446
   447 				; ------------------------------------------------------------
   448
   449 2135			.local	M0PP						; UNIT
   450
   451 2135			.local	VBL						; PROCEDURE | ASSEMBLER | INTERRUPT
   452
   453 				; ---------------------  ASM Block 060  ---------------------
   454
   455
   456 2135 A9 02 8D 4E 21		mva #2	VS_Upper
   457
   458 213A AD F4 02			lda chbas
   459 213D 8D 09 D4			sta chbase
   460 2140 49 04			eor #4
   461 2142 8D 58 21			sta VS_chbase
   462
   463 2145 4C 62 E4			jmp xitvbv
   464
   465 2148 40				rti						; ret
   466 				.endl
   467
   468 2149			.local	G0DLI						; PROCEDURE | ASSEMBLER | INTERRUPT
   469
   470 				; ---------------------  ASM Block 061  ---------------------
   471
   472
   473 2149			dli
   474 2149 48			    pha
   475
   476 214A 8D 0A D4		    sta WSYNC
   477
   478 214D A9 00		    lda #0
   479 = 214E			.def :VS_Upper = *-1
   480 214F 8D 05 D4		    sta VSCROL
   481
   482 2152 49 07		    eor #7
   483 2154 8D 4E 21		    sta VS_Upper
   484
   485 2157 A9 00		    lda #0
   486 = 2158			.def :VS_chbase = *-1
   487 2159 8D 09 D4		    sta chbase
   488
   489 215C 49 04		    eor #4
   490 215E 8D 58 21		    sta VS_chbase
   491
   492 2161 68			    pla
   493
   494 2162 40				rti						; ret
   495 				.endl
   496
   497 2163			.local	SETFONT						; PROCEDURE | ASSEMBLER
   498
   499 				; ---------------------  ASM Block 062  ---------------------
   500
   501 2163 8A 48			txa:pha
   502
   503 2165 AD F4 02			lda chbas
   504 2168 8D 81 21			sta fontcopy1+2
   505 216B 18 69 04			add #4
   506 216E 8D 84 21			sta fontcopy2+2
   507
   508 2171 A9 00			lda #0
   509 2173 8D 80 21			sta fontcopy1+1
   510 2176 A9 02			lda #2
   511 2178 8D 83 21			sta fontcopy2+1
   512
   513 217B A2 7F			ldx #127
   514 217D A0 05		fontcopy0  ldy #5
   515 217F B9 00 FF		fontcopy1  lda $ff00,y
   516 2182 99 02 FF 88		fontcopy2  sta $ff02,y-
   517 2186 10 F7		           bpl fontcopy1
   518
   519 2188 18 AD 80 21 69 08 + 	adw fontcopy1+1 #8
   520 2196 18 AD 83 21 69 08 + 	adw fontcopy2+1 #8
   521
   522 21A4 CA				dex
   523 21A5 10 D6			bpl fontcopy0
   524
   525 21A7 68 AA			pla:tax
   526
   527 21A9			@exit
   528 					.ifdef @new
   529 					lda <@VarData
   530 					sta :ztmp
   531 					lda >@VarData
   532 					ldy #@VarDataSize-1
   533 					jmp @FreeMem
   534 					eif
   535 21A9 60				rts						; ret
   536 				.endl
   537
   538 21AA			.local	DLPOKE						; PROCEDURE
   539
   540 				; ------------------------------------------------------------
   541
   542 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   543 				; as Pointer
   544 21AA B5 98 8D AF 24		mva :STACKORIGIN,x B
   545 21AF CA				dex
   546
   547 				; optimize OK (M0PP), line = 120
   548
   549 21B0 AC AD 24 84 92 AC + 	mwy DLIST :bp2
   550 21BA A0 00			ldy #$00
   551 21BC AD AF 24			lda B
   552 21BF 91 92			sta (:bp2),y
   553
   554 				; optimize FAIL (0, M0PP), line = 121
   555 21C1 EE AD 24			inc DLIST
   556 21C4 D0 03			sne
   557 21C6 EE AE 24			inc DLIST+1
   558
   559 				; ------------------------------------------------------------
   560
   561 = 24AF			B	= DATAORIGIN+$0010
   562
   563 = 24AF			@VarData	= B
   564 = 0001			@VarDataSize	= 1
   565
   566 21C9			@exit
   567 					.ifdef @new
   568 					lda <@VarData
   569 					sta :ztmp
   570 					lda >@VarData
   571 					ldy #@VarDataSize-1
   572 					jmp @FreeMem
   573 					eif
   574 21C9 60				rts						; ret
   575 				.endl
   576
   577 21CA			.local	DLPOKEW						; PROCEDURE
   578
   579 				; ------------------------------------------------------------
   580
   581 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   582 				; as Pointer
   583 21CA B5 98 8D B0 24		mva :STACKORIGIN,x W
   584 21CF B5 A8 8D B1 24		mva :STACKORIGIN+STACKWIDTH,x W+1
   585 21D4 CA				dex
   586
   587 				; optimize OK (M0PP), line = 126
   588
   589 21D5 AC AD 24 84 92 AC + 	mwy DLIST :bp2
   590 21DF A0 00			ldy #$00
   591 21E1 AD B0 24			lda W
   592 21E4 91 92			sta (:bp2),y
   593
   594 				; optimize OK (M0PP), line = 127
   595
   596 21E6 AD B1 24			lda W+1
   597 21E9 C8				iny
   598 21EA 91 92			sta (:bp2),y
   599
   600 				; optimize OK (M0PP), line = 128
   601
   602 21EC AD AD 24			lda DLIST
   603 21EF 18 69 02			add #$02
   604 21F2 8D AD 24			sta DLIST
   605 21F5 90 03			scc
   606 21F7 EE AE 24			inc DLIST+1
   607
   608 				; ------------------------------------------------------------
   609
   610 = 24B0			W	= DATAORIGIN+$0011
   611
   612 = 24B0			@VarData	= W
   613 = 0002			@VarDataSize	= 2
   614
   615 21FA			@exit
   616 					.ifdef @new
   617 					lda <@VarData
   618 					sta :ztmp
   619 					lda >@VarData
   620 					ldy #@VarDataSize-1
   621 					jmp @FreeMem
   622 					eif
   623 21FA 60				rts						; ret
   624 				.endl
   625
   626 21FB			.local	BUILDDISPLAYLIST				; PROCEDURE
   627
   628 				; ------------------------------------------------------------
   629
   630 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   631 				; as Pointer
   632 21FB B5 98 8D B7 24		mva :STACKORIGIN,x BLANKS
   633 2200 CA				dex
   634
   635 				; ------------------------------------------------------------
   636
   637 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   638 				; as Pointer
   639 2201 B5 98 8D B6 24		mva :STACKORIGIN,x LINES
   640 2206 CA				dex
   641
   642 				; ------------------------------------------------------------
   643
   644 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   645 				; as Pointer
   646 2207 B5 98 8D B4 24		mva :STACKORIGIN,x VRAMADDRESS
   647 220C B5 A8 8D B5 24		mva :STACKORIGIN+STACKWIDTH,x VRAMADDRESS+1
   648 2211 CA				dex
   649
   650 				; ------------------------------------------------------------
   651
   652 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   653 				; as Pointer
   654 2212 B5 98 8D B2 24		mva :STACKORIGIN,x DLISTADDRESS
   655 2217 B5 A8 8D B3 24		mva :STACKORIGIN+STACKWIDTH,x DLISTADDRESS+1
   656 221C CA				dex
   657
   658 				; optimize OK (M0PP), line = 133
   659
   660 221D AD B2 24 8D AD 24		mva DLISTADDRESS DLIST
   661 2223 AD B3 24 8D AE 24		mva DLISTADDRESS+1 DLIST+1
   662
   663 				; --- WhileProlog
   664 2229 4C 37 22			jmp l_009D
   665 222C			l_009E
   666
   667 				; optimize FAIL ('DLPOKE', M0PP), line = 135
   668 222C E8				inx
   669 222D A9 70 95 98			mva #$70 :STACKORIGIN,x
   670 2231 20 AA 21			jsr DLPOKE
   671
   672 				; optimize FAIL (0, M0PP), line = 136
   673 2234 CE B7 24			dec BLANKS
   674 2237			l_009D
   675
   676 				; optimize OK (M0PP), line = 134
   677
   678 2237 AD B7 24			lda BLANKS
   679 223A D0 F0			jne l_009E
   680
   681 				; optimize FAIL ('DLPOKE', M0PP), line = 138
   682 223C E8				inx
   683 223D A9 A0 95 98			mva #$A0 :STACKORIGIN,x
   684 2241 20 AA 21			jsr DLPOKE
   685
   686 				; optimize FAIL ('DLPOKE', M0PP), line = 139
   687 2244 E8				inx
   688 2245 A9 E2 95 98			mva #$E2 :STACKORIGIN,x
   689 2249 20 AA 21			jsr DLPOKE
   690
   691 				; optimize FAIL ('DLPOKEW', M0PP), line = 140
   692 224C E8				inx
   693 224D AD B4 24 95 98		mva VRAMADDRESS :STACKORIGIN,x
   694 2252 AD B5 24 95 A8		mva VRAMADDRESS+1 :STACKORIGIN+STACKWIDTH,x
   695 2257 20 CA 21			jsr DLPOKEW
   696
   697 				; optimize OK (M0PP), line = 142
   698
   699 225A AD B6 24			lda LINES
   700 225D 4A				lsr @
   701 225E 38 E9 01			sub #$01
   702 2261 8D B6 24			sta LINES
   703
   704 				; --- WhileProlog
   705 2264 4C 76 22			jmp l_00C7
   706 2267			l_00C8
   707
   708 				; optimize FAIL ('DLPOKEW', M0PP), line = 144
   709 2267 E8				inx
   710 2268 A9 82 95 98			mva #$82 :STACKORIGIN,x
   711 226C A9 A2 95 A8			mva #$A2 :STACKORIGIN+STACKWIDTH,x
   712 2270 20 CA 21			jsr DLPOKEW
   713
   714 				; optimize FAIL (0, M0PP), line = 145
   715 2273 CE B6 24			dec LINES
   716 2276			l_00C7
   717
   718 				; optimize OK (M0PP), line = 143
   719
   720 2276 AD B6 24			lda LINES
   721 2279 D0 EC			jne l_00C8
   722
   723 				; optimize FAIL ('DLPOKE', M0PP), line = 147
   724 227B E8				inx
   725 227C A9 41 95 98			mva #$41 :STACKORIGIN,x
   726 2280 20 AA 21			jsr DLPOKE
   727
   728 				; optimize FAIL ('DLPOKEW', M0PP), line = 148
   729 2283 E8				inx
   730 2284 AD B2 24 95 98		mva DLISTADDRESS :STACKORIGIN,x
   731 2289 AD B3 24 95 A8		mva DLISTADDRESS+1 :STACKORIGIN+STACKWIDTH,x
   732 228E 20 CA 21			jsr DLPOKEW
   733
   734 				; ------------------------------------------------------------
   735
   736 = 24B2			DLISTADDRESS	= DATAORIGIN+$0013
   737 = 24B4			VRAMADDRESS	= DATAORIGIN+$0015
   738 = 24B6			LINES	= DATAORIGIN+$0017
   739 = 24B7			BLANKS	= DATAORIGIN+$0018
   740
   741 = 24B2			@VarData	= DLISTADDRESS
   742 = 0006			@VarDataSize	= 6
   743
   744 2291			@exit
   745 					.ifdef @new
   746 					lda <@VarData
   747 					sta :ztmp
   748 					lda >@VarData
   749 					ldy #@VarDataSize-1
   750 					jmp @FreeMem
   751 					eif
   752 2291 60				rts						; ret
   753 				.endl
   754
   755 2292			.local	GR0INIT						; PROCEDURE
   756
   757 				; ------------------------------------------------------------
   758
   759 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   760 				; as Pointer
   761 2292 B5 98 8D BD 24		mva :STACKORIGIN,x BLANKS
   762 2297 CA				dex
   763
   764 				; ------------------------------------------------------------
   765
   766 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   767 				; as Pointer
   768 2298 B5 98 8D BC 24		mva :STACKORIGIN,x LINES
   769 229D CA				dex
   770
   771 				; ------------------------------------------------------------
   772
   773 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   774 				; as Pointer
   775 229E B5 98 8D BA 24		mva :STACKORIGIN,x VRAMADDRESS
   776 22A3 B5 A8 8D BB 24		mva :STACKORIGIN+STACKWIDTH,x VRAMADDRESS+1
   777 22A8 CA				dex
   778
   779 				; ------------------------------------------------------------
   780
   781 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   782 				; as Pointer
   783 22A9 B5 98 8D B8 24		mva :STACKORIGIN,x DLISTADDRESS
   784 22AE B5 A8 8D B9 24		mva :STACKORIGIN+STACKWIDTH,x DLISTADDRESS+1
   785 22B3 CA				dex
   786
   787 				; optimize FAIL ('SETFONT', M0PP), line = 153
   788 22B4 20 63 21			jsr SETFONT
   789
   790 				; optimize FAIL ('BUILDDISPLAYLIST', M0PP), line = 154
   791 22B7 E8				inx
   792 22B8 AD B8 24 95 98		mva DLISTADDRESS :STACKORIGIN,x
   793 22BD AD B9 24 95 A8		mva DLISTADDRESS+1 :STACKORIGIN+STACKWIDTH,x
   794 22C2 E8				inx
   795 22C3 AD BA 24 95 98		mva VRAMADDRESS :STACKORIGIN,x
   796 22C8 AD BB 24 95 A8		mva VRAMADDRESS+1 :STACKORIGIN+STACKWIDTH,x
   797 22CD E8				inx
   798 22CE AD BC 24 95 98		mva LINES :STACKORIGIN,x
   799 22D3 E8				inx
   800 22D4 AD BD 24 95 98		mva BLANKS :STACKORIGIN,x
   801 22D9 20 FB 21			jsr BUILDDISPLAYLIST
   802
   803 				; optimize OK (M0PP), line = 155
   804
   805 22DC AD B8 24 8D 30 02		mva DLISTADDRESS ATARI.SDLSTL
   806 22E2 AD B9 24 8D 31 02		mva DLISTADDRESS+1 ATARI.SDLSTL+1
   807
   808 				; optimize OK (M0PP), line = 156
   809
   810 22E8 AD BA 24 85 58		mva VRAMADDRESS ATARI.SAVMSC
   811 22ED AD BB 24 85 59		mva VRAMADDRESS+1 ATARI.SAVMSC+1
   812
   813 				; optimize OK (M0PP), line = 157
   814
   815 22F2 A9 35			lda <VBL
   816 22F4 A0 05			ldy #5
   817 22F6 8D 0A D4			sta wsync
   818 22F9 88				dey
   819 22FA D0 FD			rne
   820 22FC 8D 24 02			sta VVBLKD
   821 22FF A9 21			lda >VBL
   822 2301 8D 25 02			sta VVBLKD+1
   823
   824 				; optimize OK (M0PP), line = 158
   825
   826 2304 A9 49 8D 00 02		mva <G0DLI VDSLST
   827 2309 A9 21 8D 01 02		mva >G0DLI VDSLST+1
   828
   829 				; optimize OK (M0PP), line = 159
   830
   831 230E A9 C0 8D 0E D4		mva #$C0 ATARI.NMIEN
   832
   833 				; ------------------------------------------------------------
   834
   835 = 24B8			DLISTADDRESS	= DATAORIGIN+$0019
   836 = 24BA			VRAMADDRESS	= DATAORIGIN+$001B
   837 = 24BC			LINES	= DATAORIGIN+$001D
   838 = 24BD			BLANKS	= DATAORIGIN+$001E
   839
   840 = 24B8			@VarData	= DLISTADDRESS
   841 = 0006			@VarDataSize	= 6
   842
   843 2313			@exit
   844 					.ifdef @new
   845 					lda <@VarData
   846 					sta :ztmp
   847 					lda >@VarData
   848 					ldy #@VarDataSize-1
   849 					jmp @FreeMem
   850 					eif
   851 2313 60				rts						; ret
   852 				.endl
   853
   854 				; ------------------------------------------------------------
   855 				; ------------------------------------------------------------
   856 2314			@UnitInit
   857
   858 				; ---------------------  ASM Block 063  ---------------------
   859
   860
   861
   862 				;
   863 				; Fast E: accelerator
   864 				; -------------------
   865 				;
   866 				; Written by DMSC, loosely based on HYP.COM by Doug Wokoun and John Harris.
   867 				;
   868
   869 = E400			EDITRV	= $E400
   870
   871 = 007D			ATCLR	= $7d
   872 = 001B			ATESC	= $1b
   873
   874 2314 8A 48			txa:pha
   875
   876 					.ifdef MAIN.@DEFINES.ROMOFF
   877 						inc portb
   878 					.endif
   879
   880
   881 					; Search E: handler in HATABS
   882 2316 A0 18			ldy	#<HATABS+1-3
   883 2318 A9 45			lda	#'E'
   884 231A			search_e:
   885 231A C8				iny
   886 231B C8				iny
   887 231C C8				iny
   888 231D D9 FF 02			cmp	-1+(HATABS & $FF00),y
   889 2320 D0 F8			bne	search_e
   890
   891 					; Check high-part of HATABS address
   892 2322 B9 01 03			lda	1+(HATABS & $FF00),y
   893 2325 C9 C0			cmp	#>$C000
   894 2327 B0 05			bcs	install_ok
   895
   896 2329 A0 82			ldy #130
   897
   898 232B 4C 26 24			jmp handler_end
   899
   900 232E			install_ok
   901
   902 					; copy EDITOR handler to new HATABS
   903 232E A2 0F			ldx	#$0F
   904 2330 BD 00 E4		copy_e: lda	EDITRV,x
   905 2333 9D 64 23			sta	handler_hatab,x
   906 2336 CA				dex
   907 2337 10 F7			bpl	copy_e
   908
   909 					; Patch E: HATABS position in out handler
   910 2339 8C 58 23			sty	hatabs_l+3
   911 233C C8				iny
   912 233D 8C 5D 23			sty	hatabs_h+3
   913
   914 					; Also patch real DOSINI and EDITOR PUT
   915 				;	lda	DOSINI
   916 				;	lda	DOSINI+1
   917 				;	ldy	EDITRV+6
   918 				;	ldx	EDITRV+7
   919 				;	iny
   920 				;	sne
   921 				;	inx
   922 				;	sty	jhand+1
   923 				;	stx	jhand+2
   924
   925 					; Patch new HATABS, stored in current MEMLO
   926 2340 A9 64			lda	<EFAST
   927 2342 A2 23			ldx	>EFAST
   928
   929 2344 8D 56 23			sta	hatabs_l+1
   930 2347 8E 5B 23			stx	hatabs_h+1
   931
   932 					; And store our new PUT
   933 					; (note, C is set here, so adds 1 less)
   934 234A 69 11			adc	#(handler_put-1 - handler_hatab) - 1
   935 234C 90 01			scc
   936 234E E8				inx
   937 234F 8D 6A 23			sta	handler_hatab+6
   938 2352 8E 6B 23			stx	handler_hatab+7
   939
   940 2355			hatabs_l:
   941 2355 A9 00			lda	#$00
   942 2357 8D 1B 03			sta	HATABS+1
   943 235A			hatabs_h:
   944 235A A2 00			ldx	#$00
   945 235C 8E 1C 03			stx	HATABS+2
   946
   947 235F A0 01			ldy #1
   948
   949 2361 4C 26 24			jmp handler_end
   950
   951 2364			EFAST
   952
   953 = 2364			handler_hatab	.ds 16
   954
   955 2374-24A4> A0 00		stop	ldy #0
   956 2376 60				rts
   957
   958 					; Handler PUT function
   959 2377			handler_put:
   960 					; Don't handle wrap at last row!
   961 2377 A6 54			ldx	ROWCRS
   962 2379 E0 27			cpx	#39
   963 237B B0 F7			bcs	stop
   964
   965 					; And don't handle in graphics modes
   966 237D A6 57			ldx	DINDEX
   967 237F D0 17			bne	jhand
   968
   969 					; Check for control character:
   970 					;  $1B, $1C, $1D, $1E, $1F, $7D, $7E, $7F
   971 					;  $9B, $9C, $9D, $9E, $9F, $FD, $FE, $FF
   972 					;
   973 					; To ignore high bit, store in X the shifted character
   974 2381 0A				asl
   975 2382 A8				tay
   976 					; Restore full value in A
   977 2383 6A				ror
   978
   979 2384 C9 9B			cmp	#$9b
   980 2386 F0 13			beq	_eol
   981
   982 2388 C0 FA			cpy	#2*ATCLR	; chars >= $7D are special chars
   983 238A B0 0C			bcs	jhand
   984 238C C0 C0			cpy	#$C0		; chars >= $60 don't need conversion
   985 238E B0 1E			bcs	conv_ok
   986 2390 C0 40			cpy	#$40		; chars >= $20 needs -$20 (upper case and numbers)
   987 2392 B0 18			bcs	normal_char
   988 2394 C0 36			cpy	#2*ATESC	; chars <= $1B needs +$40 (control chars)
   989 2396 90 12			bcc	ctrl_char
   990
   991 					; Special character jump to old handler
   992 2398			jhand:	;jmp	$FFFF
   993
   994 2398 4C 74 23			jmp stop
   995
   996
   997 239B E6 54		_eol	inc	ROWCRS
   998 239D A5 52			lda	LMARGN
   999 239F 85 55			sta	COLCRS
  1000
  1001 					; Reset ESC flag
  1002 23A1 A0 00			ldy	#$00
  1003 23A3 8C A2 02			sty	ESCFLG
  1004
  1005 23A6 84 63			sty	LOGCOL
  1006
  1007 					; Return with Y = 1 (no error)
  1008 23A8 C8				iny
  1009 23A9 60				rts
  1010
  1011 					; Convert ATASCII to screen codes
  1012 23AA			ctrl_char:
  1013 23AA 69 61			adc	#$61		; Chars from $00 to $1F, add $40 (+$21, subtracted bellow)
  1014 23AC			normal_char:
  1015 23AC E9 20			sbc	#$20		; Chars from $20 to $5F, subtract $20
  1016 23AE			conv_ok:
  1017
  1018 					; Check break and stop on START/STOP flag
  1019 23AE			wait_stop:
  1020 23AE A4 11			ldy	BRKKEY
  1021 23B0 F0 E6			beq	jhand
  1022 23B2 AC FF 02			ldy	SSFLAG
  1023 23B5 D0 F7			bne	wait_stop
  1024 					; From here onwards, Y = 0 always!
  1025
  1026 					; Check if we need to recalculate cursor position
  1027 23B7 E4 5B			cpx	OLDCOL
  1028 23B9 D0 06			bne	calc_adr
  1029 23BB A6 54			ldx	ROWCRS
  1030 23BD E4 5A			cpx	OLDROW
  1031 23BF F0 39			beq	skip_adr
  1032
  1033 					; Clear current cursor position and calculate new cursor address
  1034 23C1			calc_adr:
  1035 23C1 48				pha			; Save character on STACK
  1036
  1037 23C2 A5 5D			lda	OLDCHR		; Clear cursor
  1038 23C4 91 5E			sta	(OLDADR),y
  1039
  1040 23C6 84 5F			sty	OLDADR+1	; set OLDADR+1 to 0
  1041
  1042 23C8 A5 54			lda	ROWCRS		; max =  255
  1043 23CA 85 5A			sta	OLDROW
  1044
  1045 23CC A2 00		        ldx     #0              ; clear high-byte
  1046
  1047 23CE 0A			        asl     @		; * 2
  1048 23CF 90 02		        bcc     mul4            ; high-byte affected?
  1049 23D1 A2 02		        ldx     #2              ; this will be the 1st high-bit soon...
  1050
  1051 23D3 0A			mul4:   asl     @               ; * 4
  1052 23D4 90 02		        bcc     mul5            ; high-byte affected?
  1053 23D6 E8			        inx                     ; => yes, apply to 0 high-bit
  1054 23D7 18			        clc                     ; prepare addition
  1055
  1056 23D8 65 54		mul5:   adc     ROWCRS		; * 5
  1057 23DA 90 01		        bcc     mul10		; high-byte affected?
  1058 23DC E8			        inx			; yes, correct...
  1059
  1060 23DD 86 5F		mul10:  stx     OLDADR+1	; continue with classic shifting...
  1061
  1062 23DF 0A			        asl     @		; * 10
  1063 23E0 26 5F		        rol     OLDADR+1
  1064
  1065 23E2 0A			        asl     @		; * 20
  1066 23E3 26 5F		        rol     OLDADR+1
  1067
  1068 23E5 0A			        asl     @		; * 40
  1069 23E6 26 5F		        rol     OLDADR+1
  1070
  1071 23E8 65 55			adc	COLCRS		; max = 959
  1072 23EA 90 03			bcc	@+
  1073 23EC E6 5F			inc	OLDADR+1
  1074 23EE 18				clc
  1075 23EF			@
  1076 23EF 65 58			adc	SAVMSC
  1077 23F1 85 5E			sta	OLDADR
  1078 23F3 A5 5F			lda	OLDADR+1
  1079 23F5 65 59			adc	SAVMSC+1
  1080 23F7 85 5F			sta	OLDADR+1
  1081
  1082 23F9 68				pla
  1083
  1084 23FA			skip_adr:
  1085 					; Store new character
  1086 23FA 91 5E			sta	(OLDADR),y
  1087 					; Go to next column
  1088 23FC E6 5E			inc	OLDADR
  1089 23FE D0 02			sne
  1090 2400 E6 5F			inc	OLDADR+1
  1091
  1092 					; Read new character under cursor
  1093 2402 B1 5E			lda	(OLDADR),y
  1094 2404 85 5D			sta	OLDCHR
  1095
  1096 2406 AE F0 02			ldx	CRSINH
  1097 2409 D0 04			bne	no_cursor
  1098 					; Draw cursor
  1099 240B 49 80			eor	#$80
  1100 240D 91 5E			sta	(OLDADR),y
  1101 240F			no_cursor:
  1102
  1103 					; Update column
  1104 240F A6 55			ldx	COLCRS
  1105
  1106 2411 E4 53			cpx	RMARGN
  1107 2413 90 05			bcc	@+
  1108
  1109 2415 E6 54			inc	ROWCRS
  1110 2417 A6 52			ldx	LMARGN
  1111 2419 CA				dex
  1112 241A			@
  1113 241A E8				inx
  1114
  1115 241B 86 55			stx	COLCRS
  1116 241D 86 5B			stx	OLDCOL
  1117 241F E6 63			inc	LOGCOL
  1118
  1119 					; Reset ESC flag
  1120 2421 8C A2 02			sty	ESCFLG
  1121
  1122 					; Return with Y = 1 (no error)
  1123 2424 C8				iny
  1124 2425 60				rts
  1125
  1126 				; End of resident handler
  1127 2426			handler_end:
  1128
  1129 					.ifdef MAIN.@DEFINES.ROMOFF
  1130 						dec portb
  1131 					.endif
  1132
  1133 2426 A9 FF 85 5A			mva #$ff OLDROW
  1134
  1135 242A 68 AA			pla:tax
  1136
  1137
  1138 				; optimize FAIL ('CRT.TEXTMODE', M0PP), line = 446
  1139 242C E8				inx
  1140 242D A9 00 95 98			mva #$00 :STACKORIGIN,x
  1141 2431 20 27 21			jsr CRT.TEXTMODE
  1142
  1143 2434 60				rts
  1144
  1145 				; ------------------------------------------------------------
  1146
  1147 = 0070			DL_BLANK8	= $70
  1148 = 0080			DL_DLI	= $80
  1149 = 0040			DL_LMS	= $40
  1150 = 0020			DL_VSCROLL	= $20
  1151 = 000F			DL_MODE_320X192G2	= $0F
  1152 = 0041			DL_JVB	= $41
  1153 = 24AD			DLIST	= DATAORIGIN+$000E
  1154
  1155 				.endl							; UNIT M0PP
  1156 2435			l_0007
  1157
  1158 				; optimize OK (gr_40x39.pas), line = 17
  1159
  1160 2435 A9 A0 8D F4 02		mva #$A0 ATARI.CHBAS
  1161
  1162 				; optimize FAIL ('M0PP.GR0INIT', gr_40x39.pas), line = 19
  1163 243A E8				inx
  1164 243B A9 00 95 98			mva #$00 :STACKORIGIN,x
  1165 243F A9 B8 95 A8			mva #$B8 :STACKORIGIN+STACKWIDTH,x
  1166 2443 E8				inx
  1167 2444 A9 00 95 98			mva #$00 :STACKORIGIN,x
  1168 2448 A9 A8 95 A8			mva #$A8 :STACKORIGIN+STACKWIDTH,x
  1169 244C E8				inx
  1170 244D A9 28 95 98			mva #$28 :STACKORIGIN,x
  1171 2451 E8				inx
  1172 2452 A9 00 95 98			mva #$00 :STACKORIGIN,x
  1173 2456 20 92 22			jsr M0PP.GR0INIT
  1174 				; --- For
  1175
  1176 				; optimize OK (gr_40x39.pas), line = 22
  1177
  1178 2459 A9 00 8D BE 24		mva #$00 I
  1179 245E 8D BF 24			sta I+1
  1180
  1181 				; optimize OK (gr_40x39.pas), line = 22
  1182
  1183 2461			l_011E
  1184 				; --- ForToDoCondition
  1185
  1186 				; optimize OK (gr_40x39.pas), line = 22
  1187
  1188 2461 AD BF 24			lda I+1
  1189 2464 D0 05			bne @+
  1190 2466 AD BE 24			lda I
  1191 2469 C9 27			cmp #$27
  1192 246B			@
  1193 246B B0 16			jcs l_012A
  1194
  1195 				; optimize FAIL (100, gr_40x39.pas), line = 22
  1196 246D AD BE 24			lda I
  1197 2470 AC BF 24			ldy I+1
  1198 2473 20 51 20			jsr @printWORD._ay
  1199 2476 20 3F 20			@printEOL
  1200 2479 EE BE 24			inc I
  1201 247C D0 03			sne
  1202 247E EE BF 24			inc I+1
  1203 2481 D0 DE			jne l_011E
  1204 2483			l_012A
  1205
  1206 				; --- RepeatUntilProlog
  1207 2483			l_0137
  1208
  1209 				; optimize FAIL ('CRT.KEYPRESSED', gr_40x39.pas), line = 25
  1210 2483 20 13 21			jsr CRT.KEYPRESSED
  1211 2486 CA				dex
  1212 2487 B5 99			lda :STACKORIGIN+1,x
  1213 2489 F0 F8			jeq l_0137
  1214
  1215 				; ------------------------------------------------------------
  1216
  1217 = B800			DISPLAY_LIST_ADDRESS	= $B800
  1218 = A000			CHARSET_RAM_ADDRESS	= $A000
  1219 = A800			VIDEO_RAM_ADDRESS	= $A800
  1220 = 24BE			I	= DATAORIGIN+$001F
  1221 = 0026			@FORTMP_011B	= $26
  1222 248B			@exit
  1223
  1224 248B A2 00		@halt	ldx #0
  1225 248D 9A				txs
  1226 					.ifdef MAIN.@DEFINES.ROMOFF
  1227 					inc portb
  1228 					.endif
  1229
  1230 248E 60				rts
  1231
  1232 				; ------------------------------------------------------------
  1233
  1234 248F 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  1235
  1236 				; ------------------------------------------------------------
  1237
  1238 249F			.local	@DEFINES
  1239 249F			ATARI
  1240 				.endl
  1241
  1242 				.endl							; MAIN
  1243
  1244 				; ------------------------------------------------------------
  1245 				; ------------------------------------------------------------
  1246
  1247 				.macro	UNITINITIALIZATION
  1248 				
  1249 					.ifdef MAIN.SYSTEM.@UnitInit
  1250 					jsr MAIN.SYSTEM.@UnitInit
  1251 					eif
  1252 				
  1253 					.ifdef MAIN.ATARI.@UnitInit
  1254 					jsr MAIN.ATARI.@UnitInit
  1255 					eif
  1256 				
  1257 					.ifdef MAIN.CRT.@UnitInit
  1258 					jsr MAIN.CRT.@UnitInit
  1259 					eif
  1260 				
  1261 					.ifdef MAIN.M0PP.@UnitInit
  1262 					jsr MAIN.M0PP.@UnitInit
  1263 					eif
  1264 				.endm
  1265
  1266 				; ------------------------------------------------------------
  1267
  1268 					ift .SIZEOF(MAIN.SYSTEM) > 0
  1269 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  1269 				SYSTEM: $210F..$2112
  1270 					eif
  1271
  1272 					ift .SIZEOF(MAIN.ATARI) > 0
  1273 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  1274 					eif
  1275
  1276 					ift .SIZEOF(MAIN.CRT) > 0
  1277 					.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
  1277 				CRT: $2113..$2134
  1278 					eif
  1279
  1280 					ift .SIZEOF(MAIN.M0PP) > 0
  1281 					.print 'M0PP: ',MAIN.M0PP,'..',MAIN.M0PP+.SIZEOF(MAIN.M0PP)-1
  1281 				M0PP: $2135..$2434
  1282 					eif
  1283
  1284 					.print 'CODE: ',CODEORIGIN,'..',*-1
  1284 				CODE: $2000..$249E
  1285
  1286 				; ------------------------------------------------------------
  1287
  1288 249F			DATAORIGIN
  1289 249F 28 00 18 00 2D 0C	.by  $28 $00 $18 $00 $2D $0C
  1290
  1291 = 0006			VARINITSIZE	= *-DATAORIGIN
  1292 = 0021			VARDATASIZE	= 33
  1293
  1294 = 24C0			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  1295
  1296 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  1296 				DATA: $249F..$24C0
  1297
  1298 02E0-02E1> DC 20			run START
  1299
  1300 				; ------------------------------------------------------------
  1301
  1302 				.macro	STATICDATA
  1303 				.endm
  1304
  1305 					end
