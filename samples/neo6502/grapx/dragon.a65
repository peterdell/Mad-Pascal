; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.1 [2024/01/31] for 6502
; ------------------------------------------------------------

STACKWIDTH	= 16

TRUE		= 1
FALSE		= 0

; ------------------------------------------------------------

	org $00

zpage

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

; ------------------------------------------------------------

	opt h-f+c+

	org $8000
	jmp START

CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_neo.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift VADR > $BFFF
	ert 'Invalid memory address range ',VADR
	eli (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00
	stx bp						; BP = 0

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_0004

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
DATESEPARATOR	= DATAORIGIN+$0004
FILEMODE	= DATAORIGIN+$0005
GRAPHMODE	= DATAORIGIN+$0006
IORESULT	= DATAORIGIN+$0007
EOLN	= DATAORIGIN+$0008
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	CRT						; UNIT

.local	KEYPRESSED					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000064  -------------------

	@SendMessage
	dta 2,2
	@WaitMessage
	lda DParameters
	sta result

@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$000B
	rts						; ret
.endl

; ------------------------------------------------------------

BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLINK	= $80

.endl							; UNIT CRT

; ------------------------------------------------------------

.local	NEO6502						; UNIT

; ------------------------------------------------------------

N6502MSG_ADDRESS	= $FF00
NEO_GFX_RAM	= $FFFF
adr.NEOMESSAGE	= $FF00
.var NEOMESSAGE	= adr.NEOMESSAGE .word
NEOMESSAGE.GROUP	= $FF00
NEOMESSAGE.FUNC	= $FF01
NEOMESSAGE.ERROR	= $FF02
NEOMESSAGE.STATUS	= $FF03
adr.NEOMESSAGE.PARAMS	= $FF04
.var NEOMESSAGE.PARAMS	= adr.NEOMESSAGE.PARAMS .word
adr.WORDPARAMS	= $FF04
.var WORDPARAMS	= adr.WORDPARAMS .word
adr.WORDXPARAMS	= $FF05
.var WORDXPARAMS	= adr.WORDXPARAMS .word
adr.DWORDPARAMS	= $FF04
.var DWORDPARAMS	= adr.DWORDPARAMS .word
adr.SOUNDPARAMS	= $FF04
.var SOUNDPARAMS	= adr.SOUNDPARAMS .word
SOUNDPARAMS.CHANNEL	= $FF04
SOUNDPARAMS.FREQ	= $FF05
SOUNDPARAMS.LEN	= $FF07
SOUNDPARAMS.SLIDE	= $FF09
SOUNDPARAMS.STYPE	= $FF0B

.endl							; UNIT NEO6502

; ------------------------------------------------------------

.local	TYPES						; UNIT

; ------------------------------------------------------------

.endl							; UNIT TYPES

; ------------------------------------------------------------

.local	GRAPH						; UNIT

.local	INITGRAPH					; PROCEDURE | OVERLOAD
.local	@0098
	sta MODE

; optimize OK (graph_neo.inc), line = 9

	lda #$40
	sta SYSTEM.SCREENWIDTH
	lda #$01
	sta SYSTEM.SCREENWIDTH+1

; optimize OK (graph_neo.inc), line = 10

	lda #$F0
	sta SYSTEM.SCREENHEIGHT
	lda #$00
	sta SYSTEM.SCREENHEIGHT+1

; -------------------  ASM Block 00000072  -------------------

	    @ClrScr
	
; ------------------------------------------------------------

MODE	= DATAORIGIN+$002D

@VarData	= MODE
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	SETCOLOR					; PROCEDURE | ASSEMBLER
	sta COLOR

; -------------------  ASM Block 00000074  -------------------

    lda #0
    sta	DParameters
    sta DParameters+2
    sta DParameters+3
    sta DParameters+4
    lda color
    sta DParameters+1
    @SendMessage 				
	.byte 	5,1

; ------------------------------------------------------------

COLOR	= DATAORIGIN+$002E

@VarData	= COLOR
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	LINETO						; PROCEDURE

; -------------------  ASM Block 00000078  -------------------

        mwa CurrentX DParameters
        mwa CurrentY DParameters+2
        mwa x DParameters+4
        mwa y DParameters+6
        @SendMessage 				
        .byte 	5,2
    
; optimize OK (graph_neo.inc), line = 127

	lda X
	sta CURRENTX
	lda X+1
	sta CURRENTX+1

; optimize OK (graph_neo.inc), line = 128

	lda Y
	sta CURRENTY
	lda Y+1
	sta CURRENTY+1

; ------------------------------------------------------------

X	= DATAORIGIN+$002F
Y	= DATAORIGIN+$0031

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOVETO						; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000080  -------------------

	lda y+1
	bpl _0

	lda #0
	sta y
	sta y+1
_0
	lda x+1
	bpl _1

	lda #0
	sta x
	sta x+1
_1
	cpw y main.system.ScreenHeight
	bcc _2

	sbw main.system.ScreenHeight #1 y
_2
	cpw x main.system.ScreenWidth
	bcc _3

	sbw main.system.ScreenWidth #1 x
_3
	mwa x CurrentX
	mwa y CurrentY


; ------------------------------------------------------------

X	= DATAORIGIN+$0033
Y	= DATAORIGIN+$0035

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

CURRENTDRIVER	= $80
DETECT	= $00
CGA	= $01
MCGA	= $02
EGA	= $03
EGA64	= $04
EGAMONO	= $05
LOWRES	= $06
HERCMONO	= $07
VGA	= $09
VESA	= $0A
D1BIT	= $0B
D2BIT	= $0C
D4BIT	= $0D
D6BIT	= $0E
D8BIT	= $0F
D12BIT	= $10
M640X400	= $18
M640X480	= $18
GROK	= $01
GRNOINITGRAPH	= $FF
GRNOTDETECTED	= $FE
GRFILENOTFOUND	= $FD
GRINVALIDDRIVER	= $FC
GRNOLOADMEM	= $FB
GRNOSCANMEM	= $FA
GRNOFLOODMEM	= $F9
GRFONTNOTFOUND	= $F8
GRNOFONTMEM	= $F7
GRINVALIDMODE	= $F6
GRERROR	= $F5
GRIOERROR	= $F4
GRINVALIDFONT	= $F3
GRINVALIDFONTNUM	= $F2
GRINVALIDVERSION	= $EE
CGAC0	= $00
CGAC1	= $01
CGAC2	= $02
CGAC3	= $03
CGAHI	= $04
MCGAC0	= $00
MCGAC1	= $01
MCGAC2	= $02
MCGAC3	= $03
MCGAMED	= $04
MCGAHI	= $05
EGALO	= $00
EGAHI	= $01
EGA64LO	= $00
EGA64HI	= $01
EGAMONOHI	= $03
VGALO	= $0A
VGAMED	= $1F
VGAHI	= $18
WIN_LEFT	= DATAORIGIN+$000C
WIN_RIGHT	= DATAORIGIN+$000E
WIN_TOP	= DATAORIGIN+$0010
WIN_BOTTOM	= DATAORIGIN+$0012
GRAPHRESULT	= DATAORIGIN+$0014
GETCOLOR	= DATAORIGIN+$0015
VIDEORAM	= DATAORIGIN+$0016
adr.LASTARCCOORDS	= DATAORIGIN+$0018	; [12] RECORD
.var LASTARCCOORDS	= adr.LASTARCCOORDS .word
LASTARCCOORDS.X	= DATAORIGIN+$0018
LASTARCCOORDS.Y	= DATAORIGIN+$001A
LASTARCCOORDS.XSTART	= DATAORIGIN+$001C
LASTARCCOORDS.YSTART	= DATAORIGIN+$001E
LASTARCCOORDS.XEND	= DATAORIGIN+$0020
LASTARCCOORDS.YEND	= DATAORIGIN+$0022
SCANLINE_WIDTH	= DATAORIGIN+$0024
CURRENTX	= DATAORIGIN+$0025
CURRENTY	= DATAORIGIN+$0027
LINEX	= DATAORIGIN+$0029
LINEY	= DATAORIGIN+$002B

.endl							; UNIT GRAPH

.local	DRAGON						; PROCEDURE
	.ifdef @VarData
@new	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jsr @AllocMem
	eif

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta N
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta A
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta T
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	lda :STACKORIGIN,x
	sta D
	lda :STACKORIGIN+STACKWIDTH,x
	sta D+1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta D+2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta D+3
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	lda :STACKORIGIN,x
	sta X
	lda :STACKORIGIN+STACKWIDTH,x
	sta X+1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta X+2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta X+3
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	lda :STACKORIGIN,x
	sta Y
	lda :STACKORIGIN+STACKWIDTH,x
	sta Y+1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta Y+2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta Y+3
	dex
@main

; optimize OK (dragon.pas), line = 18

	lda #$01
	cmp N
	jcc l_013A

; optimize OK (dragon.pas), line = 20

	lda C
	and #$0F
	jsr GRAPH.SETCOLOR

; optimize OK (dragon.pas), line = 21

	lda Y
	add #$80
	sta @REAL_TRUNC.A
	lda Y+1
	adc #$00
	sta @REAL_TRUNC.A+1
	lda Y+2
	adc #$00
	sta @REAL_TRUNC.A+2
	lda Y+3
	adc #$00
	sta @REAL_TRUNC.A+3
	jsr @REAL_TRUNC
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda X
	add #$80
	sta @REAL_TRUNC.A
	lda X+1
	adc #$00
	sta @REAL_TRUNC.A+1
	lda X+2
	adc #$00
	sta @REAL_TRUNC.A+2
	lda X+3
	adc #$00
	sta @REAL_TRUNC.A+3
	jsr @REAL_TRUNC
	lda :eax
	sta GRAPH.MOVETO.X
	lda :eax+1
	sta GRAPH.MOVETO.X+1
	lda :STACKORIGIN+9
	sta GRAPH.MOVETO.Y
	lda :STACKORIGIN+STACKWIDTH+9
	sta GRAPH.MOVETO.Y+1
	jsr GRAPH.MOVETO

; optimize OK (dragon.pas), line = 22

	lda A
	asl @
	asl @
	tay
	lda adr._SIN,y
	sta @REAL_MUL.B
	lda adr._SIN+1,y
	sta @REAL_MUL.B+1
	lda adr._SIN+2,y
	sta @REAL_MUL.B+2
	lda adr._SIN+3,y
	sta @REAL_MUL.B+3
	lda D
	sta @REAL_MUL.A
	lda D+1
	sta @REAL_MUL.A+1
	lda D+2
	sta @REAL_MUL.A+2
	lda D+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda Y
	add :eax
	sta :STACKORIGIN+9
	lda Y+1
	adc :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda Y+2
	adc :eax+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda Y+3
	adc :eax+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add #$80
	sta @REAL_TRUNC.A
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta @REAL_TRUNC.A+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc #$00
	sta @REAL_TRUNC.A+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$00
	sta @REAL_TRUNC.A+3
	jsr @REAL_TRUNC
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda :eax+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :eax+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda A
	asl @
	asl @
	tay
	lda adr._COS,y
	sta @REAL_MUL.B
	lda adr._COS+1,y
	sta @REAL_MUL.B+1
	lda adr._COS+2,y
	sta @REAL_MUL.B+2
	lda adr._COS+3,y
	sta @REAL_MUL.B+3
	lda D
	sta @REAL_MUL.A
	lda D+1
	sta @REAL_MUL.A+1
	lda D+2
	sta @REAL_MUL.A+2
	lda D+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda X
	add :eax
	sta :STACKORIGIN+10
	lda X+1
	adc :eax+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda X+2
	adc :eax+2
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda X+3
	adc :eax+3
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+10
	add #$80
	sta @REAL_TRUNC.A
	lda :STACKORIGIN+STACKWIDTH+10
	adc #$00
	sta @REAL_TRUNC.A+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta @REAL_TRUNC.A+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta @REAL_TRUNC.A+3
	jsr @REAL_TRUNC
	lda :eax
	sta GRAPH.LINETO.X
	lda :eax+1
	sta GRAPH.LINETO.X+1
	lda :STACKORIGIN+9
	sta GRAPH.LINETO.Y
	lda :STACKORIGIN+STACKWIDTH+9
	sta GRAPH.LINETO.Y+1
	jsr GRAPH.LINETO
	jmp @exit
l_013A

; optimize OK (dragon.pas), line = 26

	lda #$B5
	sta @REAL_MUL.B
	lda #$00
	sta @REAL_MUL.B+1
	sta @REAL_MUL.B+2
	sta @REAL_MUL.B+3
	lda D
	sta @REAL_MUL.A
	lda D+1
	sta @REAL_MUL.A+1
	lda D+2
	sta @REAL_MUL.A+2
	lda D+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda :eax
	sta D
	lda :eax+1
	sta D+1
	lda :eax+2
	sta D+2
	lda :eax+3
	sta D+3

; optimize OK (dragon.pas), line = 27

	lda A
	sub T
	and #$07
	sta A1

; optimize OK (dragon.pas), line = 28

	lda A
	add T
	and #$07
	sta A2

; optimize OK (dragon.pas), line = 29

	lda C
	add #$03
	sta C

; optimize FAIL ('DRAGON', dragon.pas), line = 30

	inx
	mva Y :STACKORIGIN,x
	mva Y+1 :STACKORIGIN+STACKWIDTH,x
	mva Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva X :STACKORIGIN,x
	mva X+1 :STACKORIGIN+STACKWIDTH,x
	mva X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva D :STACKORIGIN,x
	mva D+1 :STACKORIGIN+STACKWIDTH,x
	mva D+2 :STACKORIGIN+STACKWIDTH*2,x
	mva D+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva #$01 :STACKORIGIN,x
	inx
	mva A1 :STACKORIGIN,x
	inx
	lda N
	sub #$01
	sta :STACKORIGIN,x
	jsr DRAGON

; optimize FAIL ('DRAGON', dragon.pas), line = 31

	inx
	mva Y :STACKORIGIN,x
	mva Y+1 :STACKORIGIN+STACKWIDTH,x
	mva Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva D :STACKORIGIN,x
	mva D+1 :STACKORIGIN+STACKWIDTH,x
	mva D+2 :STACKORIGIN+STACKWIDTH*2,x
	mva D+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	lda A1
	asl @
	asl @
	tay
	lda adr._SIN,y
	sta @REAL_MUL.B
	lda adr._SIN+1,y
	sta @REAL_MUL.B+1
	lda adr._SIN+2,y
	sta @REAL_MUL.B+2
	lda adr._SIN+3,y
	sta @REAL_MUL.B+3
	lda :STACKORIGIN-1,x
	sta @REAL_MUL.A
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta @REAL_MUL.A+1
	lda :STACKORIGIN-1+STACKWIDTH*2,x
	sta @REAL_MUL.A+2
	lda :STACKORIGIN-1+STACKWIDTH*3,x
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda :eax
	sta :STACKORIGIN-1,x
	lda :eax+1
	sta :STACKORIGIN-1+STACKWIDTH,x
	lda :eax+2
	sta :STACKORIGIN-1+STACKWIDTH*2,x
	lda :eax+3
	sta :STACKORIGIN-1+STACKWIDTH*3,x
	dex
	jsr addEAX_ECX
	mva X :STACKORIGIN,x
	mva X+1 :STACKORIGIN+STACKWIDTH,x
	mva X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva D :STACKORIGIN,x
	mva D+1 :STACKORIGIN+STACKWIDTH,x
	mva D+2 :STACKORIGIN+STACKWIDTH*2,x
	mva D+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	lda A1
	asl @
	asl @
	tay
	lda adr._COS,y
	sta @REAL_MUL.B
	lda adr._COS+1,y
	sta @REAL_MUL.B+1
	lda adr._COS+2,y
	sta @REAL_MUL.B+2
	lda adr._COS+3,y
	sta @REAL_MUL.B+3
	lda :STACKORIGIN-1,x
	sta @REAL_MUL.A
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta @REAL_MUL.A+1
	lda :STACKORIGIN-1+STACKWIDTH*2,x
	sta @REAL_MUL.A+2
	lda :STACKORIGIN-1+STACKWIDTH*3,x
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda :eax
	sta :STACKORIGIN-1,x
	lda :eax+1
	sta :STACKORIGIN-1+STACKWIDTH,x
	lda :eax+2
	sta :STACKORIGIN-1+STACKWIDTH*2,x
	lda :eax+3
	sta :STACKORIGIN-1+STACKWIDTH*3,x
	dex
	jsr addEAX_ECX
	mva D :STACKORIGIN,x
	mva D+1 :STACKORIGIN+STACKWIDTH,x
	mva D+2 :STACKORIGIN+STACKWIDTH*2,x
	mva D+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva #$FF :STACKORIGIN,x
	inx
	mva A2 :STACKORIGIN,x
	inx
	lda N
	sub #$01
	sta :STACKORIGIN,x
	jsr DRAGON

; ------------------------------------------------------------

N	= DATAORIGIN+$003C
A	= DATAORIGIN+$003D
T	= DATAORIGIN+$003E
D	= DATAORIGIN+$003F
X	= DATAORIGIN+$0043
Y	= DATAORIGIN+$0047
A1	= DATAORIGIN+$004B
A2	= DATAORIGIN+$004C

@VarData	= N
@VarDataSize	= 17

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_0004

; optimize OK (dragon.pas), line = 35

	lda #$00
	jsr GRAPH.INITGRAPH.@0098

; optimize OK (dragon.pas), line = 36

	lda #$00
	sta C

; optimize FAIL ('DRAGON', dragon.pas), line = 37

	inx
	mva #$00 :STACKORIGIN,x
	mva #$96 :STACKORIGIN+STACKWIDTH,x
	mva #$00 :STACKORIGIN+STACKWIDTH*2,x
	sta :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$5A :STACKORIGIN+STACKWIDTH,x
	mva #$00 :STACKORIGIN+STACKWIDTH*2,x
	sta :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$B4 :STACKORIGIN+STACKWIDTH,x
	mva #$00 :STACKORIGIN+STACKWIDTH*2,x
	sta :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva #$01 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	inx
	mva #$0E :STACKORIGIN,x
	jsr DRAGON

; --- RepeatUntilProlog
l_01DD

; optimize FAIL ('CRT.KEYPRESSED', dragon.pas), line = 38

	jsr CRT.KEYPRESSED
	lda CRT.KEYPRESSED.RESULT
	jeq l_01DD

; ------------------------------------------------------------

S	= $B5
adr._SIN	= CODEORIGIN+$0000
.var _SIN	= adr._SIN .word
adr._COS	= CODEORIGIN+$0020
.var _COS	= adr._COS .word
SEP	= $B4
GD	= DATAORIGIN+$0037
GM	= DATAORIGIN+$0039
C	= DATAORIGIN+$003B
@exit

@halt	ldx #$00
	txs

	rts

; ------------------------------------------------------------

; ------------------------------------------------------------

.local	@DEFINES
NEO
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi

	.ifdef MAIN.NEO6502.@UnitInit
	jsr MAIN.NEO6502.@UnitInit
	.fi

	.ifdef MAIN.TYPES.@UnitInit
	jsr MAIN.TYPES.@UnitInit
	.fi

	.ifdef MAIN.GRAPH.@UnitInit
	jsr MAIN.GRAPH.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

	ift .SIZEOF(MAIN.NEO6502) > 0
	.print 'NEO6502: ',MAIN.NEO6502,'..',MAIN.NEO6502+.SIZEOF(MAIN.NEO6502)-1
	eif

	ift .SIZEOF(MAIN.TYPES) > 0
	.print 'TYPES: ',MAIN.TYPES,'..',MAIN.TYPES+.SIZEOF(MAIN.TYPES)-1
	eif

	ift .SIZEOF(MAIN.GRAPH) > 0
	.print 'GRAPH: ',MAIN.GRAPH,'..',MAIN.GRAPH+.SIZEOF(MAIN.GRAPH)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $00 $27 $00  $00 $00 $17

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 77

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

; ------------------------------------------------------------

.macro	STATICDATA
.by  $00 $00 $00 $00 $B5 $00 $00 $00  $00 $01 $00 $00 $B5 $00 $00 $00  $00 $00 $00 $00 $4B $FF $FF $FF
.by  $00 $FF $FF $FF $4B $FF $FF $FF  $00 $01 $00 $00 $B5 $00 $00 $00  $00 $00 $00 $00 $4B $FF $FF $FF
.by  $00 $FF $FF $FF $4B $FF $FF $FF  $00 $00 $00 $00 $B5 $00 $00 $00
.endm

	end
