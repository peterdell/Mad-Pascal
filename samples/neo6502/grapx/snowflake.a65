; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.1 [2024/01/31] for 6502
; ------------------------------------------------------------

STACKWIDTH	= 16

TRUE		= 1
FALSE		= 0

; ------------------------------------------------------------

	org $00

zpage

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

; ------------------------------------------------------------

	opt h-f+c+

	org $8000
	jmp START

CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_neo.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift VADR > $BFFF
	ert 'Invalid memory address range ',VADR
	eli (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00
	stx bp						; BP = 0

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_0004

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
DATESEPARATOR	= DATAORIGIN+$0004
FILEMODE	= DATAORIGIN+$0005
GRAPHMODE	= DATAORIGIN+$0006
IORESULT	= DATAORIGIN+$0007
EOLN	= DATAORIGIN+$0008
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	CRT						; UNIT

.local	KEYPRESSED					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000064  -------------------

	@SendMessage
	dta 2,2
	@WaitMessage
	lda DParameters
	sta result

@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$000B
	rts						; ret
.endl

; ------------------------------------------------------------

BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLINK	= $80

.endl							; UNIT CRT

; ------------------------------------------------------------

.local	TYPES						; UNIT

; ------------------------------------------------------------

.endl							; UNIT TYPES

; ------------------------------------------------------------

.local	GRAPH						; UNIT

.local	INITGRAPH					; PROCEDURE | OVERLOAD
.local	@0097
	sta MODE

; optimize OK (graph_neo.inc), line = 9

	lda #$40
	sta SYSTEM.SCREENWIDTH
	lda #$01
	sta SYSTEM.SCREENWIDTH+1

; optimize OK (graph_neo.inc), line = 10

	lda #$F0
	sta SYSTEM.SCREENHEIGHT
	lda #$00
	sta SYSTEM.SCREENHEIGHT+1

; -------------------  ASM Block 00000071  -------------------

	    @ClrScr
	
; ------------------------------------------------------------

MODE	= DATAORIGIN+$002D

@VarData	= MODE
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	SETCOLOR					; PROCEDURE | ASSEMBLER
	sta COLOR

; -------------------  ASM Block 00000073  -------------------

    lda #0
    sta	DParameters
    sta DParameters+2
    sta DParameters+3
    sta DParameters+4
    lda color
    sta DParameters+1
    @SendMessage 				
	.byte 	5,1

; ------------------------------------------------------------

COLOR	= DATAORIGIN+$002E

@VarData	= COLOR
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	LINETO						; PROCEDURE

; -------------------  ASM Block 00000077  -------------------

        mwa CurrentX DParameters
        mwa CurrentY DParameters+2
        mwa x DParameters+4
        mwa y DParameters+6
        @SendMessage 				
        .byte 	5,2
    
; optimize OK (graph_neo.inc), line = 127

	lda X
	sta CURRENTX
	lda X+1
	sta CURRENTX+1

; optimize OK (graph_neo.inc), line = 128

	lda Y
	sta CURRENTY
	lda Y+1
	sta CURRENTY+1

; ------------------------------------------------------------

X	= DATAORIGIN+$002F
Y	= DATAORIGIN+$0031

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOVETO						; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000079  -------------------

	lda y+1
	bpl _0

	lda #0
	sta y
	sta y+1
_0
	lda x+1
	bpl _1

	lda #0
	sta x
	sta x+1
_1
	cpw y main.system.ScreenHeight
	bcc _2

	sbw main.system.ScreenHeight #1 y
_2
	cpw x main.system.ScreenWidth
	bcc _3

	sbw main.system.ScreenWidth #1 x
_3
	mwa x CurrentX
	mwa y CurrentY


; ------------------------------------------------------------

X	= DATAORIGIN+$0033
Y	= DATAORIGIN+$0035

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

CURRENTDRIVER	= $80
DETECT	= $00
CGA	= $01
MCGA	= $02
EGA	= $03
EGA64	= $04
EGAMONO	= $05
LOWRES	= $06
HERCMONO	= $07
VGA	= $09
VESA	= $0A
D1BIT	= $0B
D2BIT	= $0C
D4BIT	= $0D
D6BIT	= $0E
D8BIT	= $0F
D12BIT	= $10
M640X400	= $18
M640X480	= $18
GROK	= $01
GRNOINITGRAPH	= $FF
GRNOTDETECTED	= $FE
GRFILENOTFOUND	= $FD
GRINVALIDDRIVER	= $FC
GRNOLOADMEM	= $FB
GRNOSCANMEM	= $FA
GRNOFLOODMEM	= $F9
GRFONTNOTFOUND	= $F8
GRNOFONTMEM	= $F7
GRINVALIDMODE	= $F6
GRERROR	= $F5
GRIOERROR	= $F4
GRINVALIDFONT	= $F3
GRINVALIDFONTNUM	= $F2
GRINVALIDVERSION	= $EE
CGAC0	= $00
CGAC1	= $01
CGAC2	= $02
CGAC3	= $03
CGAHI	= $04
MCGAC0	= $00
MCGAC1	= $01
MCGAC2	= $02
MCGAC3	= $03
MCGAMED	= $04
MCGAHI	= $05
EGALO	= $00
EGAHI	= $01
EGA64LO	= $00
EGA64HI	= $01
EGAMONOHI	= $03
VGALO	= $0A
VGAMED	= $1F
VGAHI	= $18
WIN_LEFT	= DATAORIGIN+$000C
WIN_RIGHT	= DATAORIGIN+$000E
WIN_TOP	= DATAORIGIN+$0010
WIN_BOTTOM	= DATAORIGIN+$0012
GRAPHRESULT	= DATAORIGIN+$0014
GETCOLOR	= DATAORIGIN+$0015
VIDEORAM	= DATAORIGIN+$0016
adr.LASTARCCOORDS	= DATAORIGIN+$0018	; [12] RECORD
.var LASTARCCOORDS	= adr.LASTARCCOORDS .word
LASTARCCOORDS.X	= DATAORIGIN+$0018
LASTARCCOORDS.Y	= DATAORIGIN+$001A
LASTARCCOORDS.XSTART	= DATAORIGIN+$001C
LASTARCCOORDS.YSTART	= DATAORIGIN+$001E
LASTARCCOORDS.XEND	= DATAORIGIN+$0020
LASTARCCOORDS.YEND	= DATAORIGIN+$0022
SCANLINE_WIDTH	= DATAORIGIN+$0024
CURRENTX	= DATAORIGIN+$0025
CURRENTY	= DATAORIGIN+$0027
LINEX	= DATAORIGIN+$0029
LINEY	= DATAORIGIN+$002B

.endl							; UNIT GRAPH

.local	LINETO2D					; PROCEDURE

; optimize OK (snowflake.pas), line = 27

	lda AY
	sta @REAL_ROUND.A
	lda AY+1
	sta @REAL_ROUND.A+1
	lda AY+2
	sta @REAL_ROUND.A+2
	lda AY+3
	sta @REAL_ROUND.A+3
	jsr @REAL_ROUND
	lda :eax
	add #$64
	sta :STACKORIGIN+9
	lda :eax+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda AX
	sta @REAL_ROUND.A
	lda AX+1
	sta @REAL_ROUND.A+1
	lda AX+2
	sta @REAL_ROUND.A+2
	lda AX+3
	sta @REAL_ROUND.A+3
	jsr @REAL_ROUND
	lda :eax
	add #$A0
	sta GRAPH.LINETO.X
	lda :eax+1
	adc #$00
	sta GRAPH.LINETO.X+1
	lda :STACKORIGIN+9
	sta GRAPH.LINETO.Y
	lda :STACKORIGIN+STACKWIDTH+9
	sta GRAPH.LINETO.Y+1
	jsr GRAPH.LINETO

; ------------------------------------------------------------

AX	= DATAORIGIN+$003B
AY	= DATAORIGIN+$003F

@VarData	= AX
@VarDataSize	= 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOVETO2D					; PROCEDURE

; optimize OK (snowflake.pas), line = 32

	lda AY
	sta @REAL_ROUND.A
	lda AY+1
	sta @REAL_ROUND.A+1
	lda AY+2
	sta @REAL_ROUND.A+2
	lda AY+3
	sta @REAL_ROUND.A+3
	jsr @REAL_ROUND
	lda :eax
	add #$64
	sta :STACKORIGIN+9
	lda :eax+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda AX
	sta @REAL_ROUND.A
	lda AX+1
	sta @REAL_ROUND.A+1
	lda AX+2
	sta @REAL_ROUND.A+2
	lda AX+3
	sta @REAL_ROUND.A+3
	jsr @REAL_ROUND
	lda :eax
	add #$A0
	sta GRAPH.MOVETO.X
	lda :eax+1
	adc #$00
	sta GRAPH.MOVETO.X+1
	lda :STACKORIGIN+9
	sta GRAPH.MOVETO.Y
	lda :STACKORIGIN+STACKWIDTH+9
	sta GRAPH.MOVETO.Y+1
	jsr GRAPH.MOVETO

; ------------------------------------------------------------

AX	= DATAORIGIN+$0043
AY	= DATAORIGIN+$0047

@VarData	= AX
@VarDataSize	= 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	NEXTSEGMENTS					; PROCEDURE
	.ifdef @VarData
@new	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jsr @AllocMem
	eif

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	lda :STACKORIGIN,x
	sta AX
	lda :STACKORIGIN+STACKWIDTH,x
	sta AX+1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta AX+2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta AX+3
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	lda :STACKORIGIN,x
	sta AY
	lda :STACKORIGIN+STACKWIDTH,x
	sta AY+1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta AY+2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta AY+3
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	lda :STACKORIGIN,x
	sta BX
	lda :STACKORIGIN+STACKWIDTH,x
	sta BX+1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta BX+2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta BX+3
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	lda :STACKORIGIN,x
	sta BY
	lda :STACKORIGIN+STACKWIDTH,x
	sta BY+1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta BY+2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta BY+3
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta N
	dex
@main

; optimize OK (snowflake.pas), line = 45

	lda N
	jeq l_0154

; optimize OK (snowflake.pas), line = 48

	lda AX
	add AX
	sta :STACKORIGIN+9
	lda AX+1
	adc AX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda AX+2
	adc AX+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda AX+3
	adc AX+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add BX
	sta @REAL_DIV.A
	lda :STACKORIGIN+STACKWIDTH+9
	adc BX+1
	sta @REAL_DIV.A+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc BX+2
	sta @REAL_DIV.A+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc BX+3
	sta @REAL_DIV.A+3
	lda #$00
	sta @REAL_DIV.B
	lda #$03
	sta @REAL_DIV.B+1
	lda #$00
	sta @REAL_DIV.B+2
	sta @REAL_DIV.B+3
	jsr @REAL_DIV
	lda :eax
	sta R.X
	lda :eax+1
	sta R.X+1
	lda :eax+2
	sta R.X+2
	lda :eax+3
	sta R.X+3

; optimize OK (snowflake.pas), line = 49

	lda AY
	add AY
	sta :STACKORIGIN+9
	lda AY+1
	adc AY+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda AY+2
	adc AY+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda AY+3
	adc AY+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add BY
	sta @REAL_DIV.A
	lda :STACKORIGIN+STACKWIDTH+9
	adc BY+1
	sta @REAL_DIV.A+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc BY+2
	sta @REAL_DIV.A+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc BY+3
	sta @REAL_DIV.A+3
	lda #$00
	sta @REAL_DIV.B
	lda #$03
	sta @REAL_DIV.B+1
	lda #$00
	sta @REAL_DIV.B+2
	sta @REAL_DIV.B+3
	jsr @REAL_DIV
	lda :eax
	sta R.Y
	lda :eax+1
	sta R.Y+1
	lda :eax+2
	sta R.Y+2
	lda :eax+3
	sta R.Y+3

; optimize OK (snowflake.pas), line = 51

	lda AX
	add BX
	sta :STACKORIGIN+9
	lda AX+1
	adc BX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda AX+2
	adc BX+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda AX+3
	adc BX+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add BX
	sta @REAL_DIV.A
	lda :STACKORIGIN+STACKWIDTH+9
	adc BX+1
	sta @REAL_DIV.A+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc BX+2
	sta @REAL_DIV.A+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc BX+3
	sta @REAL_DIV.A+3
	lda #$00
	sta @REAL_DIV.B
	lda #$03
	sta @REAL_DIV.B+1
	lda #$00
	sta @REAL_DIV.B+2
	sta @REAL_DIV.B+3
	jsr @REAL_DIV
	lda :eax
	sta T.X
	lda :eax+1
	sta T.X+1
	lda :eax+2
	sta T.X+2
	lda :eax+3
	sta T.X+3

; optimize OK (snowflake.pas), line = 52

	lda AY
	add BY
	sta :STACKORIGIN+9
	lda AY+1
	adc BY+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda AY+2
	adc BY+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda AY+3
	adc BY+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add BY
	sta @REAL_DIV.A
	lda :STACKORIGIN+STACKWIDTH+9
	adc BY+1
	sta @REAL_DIV.A+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc BY+2
	sta @REAL_DIV.A+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc BY+3
	sta @REAL_DIV.A+3
	lda #$00
	sta @REAL_DIV.B
	lda #$03
	sta @REAL_DIV.B+1
	lda #$00
	sta @REAL_DIV.B+2
	sta @REAL_DIV.B+3
	jsr @REAL_DIV
	lda :eax
	sta T.Y
	lda :eax+1
	sta T.Y+1
	lda :eax+2
	sta T.Y+2
	lda :eax+3
	sta T.Y+3

; optimize OK (snowflake.pas), line = 54

	lda AX
	add BX
	sta @REAL_MUL.A
	lda AX+1
	adc BX+1
	sta @REAL_MUL.A+1
	lda AX+2
	adc BX+2
	sta @REAL_MUL.A+2
	lda AX+3
	adc BX+3
	sta @REAL_MUL.A+3
	lda #$80
	sta @REAL_MUL.B
	lda #$00
	sta @REAL_MUL.B+1
	sta @REAL_MUL.B+2
	sta @REAL_MUL.B+3
	jsr @REAL_MUL
	lda :eax
	sta MIDDLE.X
	lda :eax+1
	sta MIDDLE.X+1
	lda :eax+2
	sta MIDDLE.X+2
	lda :eax+3
	sta MIDDLE.X+3

; optimize OK (snowflake.pas), line = 55

	lda AY
	add BY
	sta @REAL_MUL.A
	lda AY+1
	adc BY+1
	sta @REAL_MUL.A+1
	lda AY+2
	adc BY+2
	sta @REAL_MUL.A+2
	lda AY+3
	adc BY+3
	sta @REAL_MUL.A+3
	lda #$80
	sta @REAL_MUL.B
	lda #$00
	sta @REAL_MUL.B+1
	sta @REAL_MUL.B+2
	sta @REAL_MUL.B+3
	jsr @REAL_MUL
	lda :eax
	sta MIDDLE.Y
	lda :eax+1
	sta MIDDLE.Y+1
	lda :eax+2
	sta MIDDLE.Y+2
	lda :eax+3
	sta MIDDLE.Y+3

; optimize OK (snowflake.pas), line = 57

	lda BX
	sub AX
	sta XDELTA
	lda BX+1
	sbc AX+1
	sta XDELTA+1
	lda BX+2
	sbc AX+2
	sta XDELTA+2
	lda BX+3
	sbc AX+3
	sta XDELTA+3

; optimize OK (snowflake.pas), line = 58

	lda BY
	sub AY
	sta YDELTA
	lda BY+1
	sbc AY+1
	sta YDELTA+1
	lda BY+2
	sbc AY+2
	sta YDELTA+2
	lda BY+3
	sbc AY+3
	sta YDELTA+3

; optimize OK (snowflake.pas), line = 60

	lda YDELTA
	sta @REAL_MUL.B
	lda YDELTA+1
	sta @REAL_MUL.B+1
	lda YDELTA+2
	sta @REAL_MUL.B+2
	lda YDELTA+3
	sta @REAL_MUL.B+3
	lda #$4A
	sta @REAL_MUL.A
	lda #$00
	sta @REAL_MUL.A+1
	sta @REAL_MUL.A+2
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda MIDDLE.X
	add :eax
	sta S.X
	lda MIDDLE.X+1
	adc :eax+1
	sta S.X+1
	lda MIDDLE.X+2
	adc :eax+2
	sta S.X+2
	lda MIDDLE.X+3
	adc :eax+3
	sta S.X+3

; optimize OK (snowflake.pas), line = 61

	lda XDELTA
	sta @REAL_MUL.B
	lda XDELTA+1
	sta @REAL_MUL.B+1
	lda XDELTA+2
	sta @REAL_MUL.B+2
	lda XDELTA+3
	sta @REAL_MUL.B+3
	lda #$4A
	sta @REAL_MUL.A
	lda #$00
	sta @REAL_MUL.A+1
	sta @REAL_MUL.A+2
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda MIDDLE.Y
	sub :eax
	sta S.Y
	lda MIDDLE.Y+1
	sbc :eax+1
	sta S.Y+1
	lda MIDDLE.Y+2
	sbc :eax+2
	sta S.Y+2
	lda MIDDLE.Y+3
	sbc :eax+3
	sta S.Y+3

; optimize OK (snowflake.pas), line = 63

	lda #$00
	jsr GRAPH.SETCOLOR

; optimize OK (snowflake.pas), line = 64

	lda AX
	sta MOVETO2D.AX
	lda AX+1
	sta MOVETO2D.AX+1
	lda AX+2
	sta MOVETO2D.AX+2
	lda AX+3
	sta MOVETO2D.AX+3
	lda AY
	sta MOVETO2D.AY
	lda AY+1
	sta MOVETO2D.AY+1
	lda AY+2
	sta MOVETO2D.AY+2
	lda AY+3
	sta MOVETO2D.AY+3
	jsr MOVETO2D

; optimize OK (snowflake.pas), line = 65

	lda BX
	sta LINETO2D.AX
	lda BX+1
	sta LINETO2D.AX+1
	lda BX+2
	sta LINETO2D.AX+2
	lda BX+3
	sta LINETO2D.AX+3
	lda BY
	sta LINETO2D.AY
	lda BY+1
	sta LINETO2D.AY+1
	lda BY+2
	sta LINETO2D.AY+2
	lda BY+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize OK (snowflake.pas), line = 67

	lda #$0F
	jsr GRAPH.SETCOLOR

; optimize OK (snowflake.pas), line = 68

	lda AX
	sta MOVETO2D.AX
	lda AX+1
	sta MOVETO2D.AX+1
	lda AX+2
	sta MOVETO2D.AX+2
	lda AX+3
	sta MOVETO2D.AX+3
	lda AY
	sta MOVETO2D.AY
	lda AY+1
	sta MOVETO2D.AY+1
	lda AY+2
	sta MOVETO2D.AY+2
	lda AY+3
	sta MOVETO2D.AY+3
	jsr MOVETO2D

; optimize OK (snowflake.pas), line = 69

	lda R.X
	sta LINETO2D.AX
	lda R.X+1
	sta LINETO2D.AX+1
	lda R.X+2
	sta LINETO2D.AX+2
	lda R.X+3
	sta LINETO2D.AX+3
	lda R.Y
	sta LINETO2D.AY
	lda R.Y+1
	sta LINETO2D.AY+1
	lda R.Y+2
	sta LINETO2D.AY+2
	lda R.Y+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize OK (snowflake.pas), line = 70

	lda S.X
	sta LINETO2D.AX
	lda S.X+1
	sta LINETO2D.AX+1
	lda S.X+2
	sta LINETO2D.AX+2
	lda S.X+3
	sta LINETO2D.AX+3
	lda S.Y
	sta LINETO2D.AY
	lda S.Y+1
	sta LINETO2D.AY+1
	lda S.Y+2
	sta LINETO2D.AY+2
	lda S.Y+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize OK (snowflake.pas), line = 71

	lda T.X
	sta LINETO2D.AX
	lda T.X+1
	sta LINETO2D.AX+1
	lda T.X+2
	sta LINETO2D.AX+2
	lda T.X+3
	sta LINETO2D.AX+3
	lda T.Y
	sta LINETO2D.AY
	lda T.Y+1
	sta LINETO2D.AY+1
	lda T.Y+2
	sta LINETO2D.AY+2
	lda T.Y+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize OK (snowflake.pas), line = 72

	lda BX
	sta LINETO2D.AX
	lda BX+1
	sta LINETO2D.AX+1
	lda BX+2
	sta LINETO2D.AX+2
	lda BX+3
	sta LINETO2D.AX+3
	lda BY
	sta LINETO2D.AY
	lda BY+1
	sta LINETO2D.AY+1
	lda BY+2
	sta LINETO2D.AY+2
	lda BY+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize FAIL ('NEXTSEGMENTS', snowflake.pas), line = 74

	inx
	ldy N
	dey
	sty :STACKORIGIN,x
	inx
	mva R.Y :STACKORIGIN,x
	mva R.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva R.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva R.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva R.X :STACKORIGIN,x
	mva R.X+1 :STACKORIGIN+STACKWIDTH,x
	mva R.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva R.X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva AY :STACKORIGIN,x
	mva AY+1 :STACKORIGIN+STACKWIDTH,x
	mva AY+2 :STACKORIGIN+STACKWIDTH*2,x
	mva AY+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva AX :STACKORIGIN,x
	mva AX+1 :STACKORIGIN+STACKWIDTH,x
	mva AX+2 :STACKORIGIN+STACKWIDTH*2,x
	mva AX+3 :STACKORIGIN+STACKWIDTH*3,x
	jsr NEXTSEGMENTS

; optimize FAIL ('NEXTSEGMENTS', snowflake.pas), line = 75

	inx
	ldy N
	dey
	sty :STACKORIGIN,x
	inx
	mva S.Y :STACKORIGIN,x
	mva S.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva S.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva S.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva S.X :STACKORIGIN,x
	mva S.X+1 :STACKORIGIN+STACKWIDTH,x
	mva S.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva S.X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva R.Y :STACKORIGIN,x
	mva R.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva R.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva R.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva R.X :STACKORIGIN,x
	mva R.X+1 :STACKORIGIN+STACKWIDTH,x
	mva R.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva R.X+3 :STACKORIGIN+STACKWIDTH*3,x
	jsr NEXTSEGMENTS

; optimize FAIL ('NEXTSEGMENTS', snowflake.pas), line = 76

	inx
	ldy N
	dey
	sty :STACKORIGIN,x
	inx
	mva T.Y :STACKORIGIN,x
	mva T.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva T.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva T.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva T.X :STACKORIGIN,x
	mva T.X+1 :STACKORIGIN+STACKWIDTH,x
	mva T.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva T.X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva S.Y :STACKORIGIN,x
	mva S.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva S.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva S.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva S.X :STACKORIGIN,x
	mva S.X+1 :STACKORIGIN+STACKWIDTH,x
	mva S.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva S.X+3 :STACKORIGIN+STACKWIDTH*3,x
	jsr NEXTSEGMENTS

; optimize FAIL ('NEXTSEGMENTS', snowflake.pas), line = 77

	inx
	ldy N
	dey
	sty :STACKORIGIN,x
	inx
	mva BY :STACKORIGIN,x
	mva BY+1 :STACKORIGIN+STACKWIDTH,x
	mva BY+2 :STACKORIGIN+STACKWIDTH*2,x
	mva BY+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva BX :STACKORIGIN,x
	mva BX+1 :STACKORIGIN+STACKWIDTH,x
	mva BX+2 :STACKORIGIN+STACKWIDTH*2,x
	mva BX+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva T.Y :STACKORIGIN,x
	mva T.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva T.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva T.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva T.X :STACKORIGIN,x
	mva T.X+1 :STACKORIGIN+STACKWIDTH,x
	mva T.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva T.X+3 :STACKORIGIN+STACKWIDTH*3,x
	jsr NEXTSEGMENTS
l_0154

; ------------------------------------------------------------

AX	= DATAORIGIN+$004B
AY	= DATAORIGIN+$004F
BX	= DATAORIGIN+$0053
BY	= DATAORIGIN+$0057
N	= DATAORIGIN+$005B
FACTOR	= $4A
adr.MIDDLE	= DATAORIGIN+$005C	; [8] RECORD
.var MIDDLE	= adr.MIDDLE .word
MIDDLE.X	= DATAORIGIN+$005C
MIDDLE.Y	= DATAORIGIN+$0060
XDELTA	= DATAORIGIN+$0064
YDELTA	= DATAORIGIN+$0068
adr.R	= DATAORIGIN+$006C	; [8] RECORD
.var R	= adr.R .word
R.X	= DATAORIGIN+$006C
R.Y	= DATAORIGIN+$0070
adr.S	= DATAORIGIN+$0074	; [8] RECORD
.var S	= adr.S .word
S.X	= DATAORIGIN+$0074
S.Y	= DATAORIGIN+$0078
adr.T	= DATAORIGIN+$007C	; [8] RECORD
.var T	= adr.T .word
T.X	= DATAORIGIN+$007C
T.Y	= DATAORIGIN+$0080

@VarData	= AX
@VarDataSize	= 57

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	KOCHSNOWFLAKE					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$07
	mva:rpl (:bp2),y adr.A,y-
	mwa #adr.A A
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$07
	mva:rpl (:bp2),y adr.B,y-
	mwa #adr.B B
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$07
	mva:rpl (:bp2),y adr.C,y-
	mwa #adr.C C
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta N
	dex
@main

; optimize OK (snowflake.pas), line = 84

	lda #$01
	jsr GRAPH.SETCOLOR

; optimize OK (snowflake.pas), line = 85

	lda A.X
	sta MOVETO2D.AX
	lda A.X+1
	sta MOVETO2D.AX+1
	lda A.X+2
	sta MOVETO2D.AX+2
	lda A.X+3
	sta MOVETO2D.AX+3
	lda A.Y
	sta MOVETO2D.AY
	lda A.Y+1
	sta MOVETO2D.AY+1
	lda A.Y+2
	sta MOVETO2D.AY+2
	lda A.Y+3
	sta MOVETO2D.AY+3
	jsr MOVETO2D

; optimize OK (snowflake.pas), line = 86

	lda B.X
	sta LINETO2D.AX
	lda B.X+1
	sta LINETO2D.AX+1
	lda B.X+2
	sta LINETO2D.AX+2
	lda B.X+3
	sta LINETO2D.AX+3
	lda B.Y
	sta LINETO2D.AY
	lda B.Y+1
	sta LINETO2D.AY+1
	lda B.Y+2
	sta LINETO2D.AY+2
	lda B.Y+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize FAIL ('NEXTSEGMENTS', snowflake.pas), line = 87

	inx
	mva N :STACKORIGIN,x
	inx
	mva B.Y :STACKORIGIN,x
	mva B.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva B.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva B.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva B.X :STACKORIGIN,x
	mva B.X+1 :STACKORIGIN+STACKWIDTH,x
	mva B.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva B.X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva A.Y :STACKORIGIN,x
	mva A.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva A.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva A.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva A.X :STACKORIGIN,x
	mva A.X+1 :STACKORIGIN+STACKWIDTH,x
	mva A.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva A.X+3 :STACKORIGIN+STACKWIDTH*3,x
	jsr NEXTSEGMENTS

; optimize OK (snowflake.pas), line = 89

	lda B.X
	sta MOVETO2D.AX
	lda B.X+1
	sta MOVETO2D.AX+1
	lda B.X+2
	sta MOVETO2D.AX+2
	lda B.X+3
	sta MOVETO2D.AX+3
	lda B.Y
	sta MOVETO2D.AY
	lda B.Y+1
	sta MOVETO2D.AY+1
	lda B.Y+2
	sta MOVETO2D.AY+2
	lda B.Y+3
	sta MOVETO2D.AY+3
	jsr MOVETO2D

; optimize OK (snowflake.pas), line = 90

	lda C.X
	sta LINETO2D.AX
	lda C.X+1
	sta LINETO2D.AX+1
	lda C.X+2
	sta LINETO2D.AX+2
	lda C.X+3
	sta LINETO2D.AX+3
	lda C.Y
	sta LINETO2D.AY
	lda C.Y+1
	sta LINETO2D.AY+1
	lda C.Y+2
	sta LINETO2D.AY+2
	lda C.Y+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize FAIL ('NEXTSEGMENTS', snowflake.pas), line = 91

	inx
	mva N :STACKORIGIN,x
	inx
	mva C.Y :STACKORIGIN,x
	mva C.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva C.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva C.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva C.X :STACKORIGIN,x
	mva C.X+1 :STACKORIGIN+STACKWIDTH,x
	mva C.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva C.X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva B.Y :STACKORIGIN,x
	mva B.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva B.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva B.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva B.X :STACKORIGIN,x
	mva B.X+1 :STACKORIGIN+STACKWIDTH,x
	mva B.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva B.X+3 :STACKORIGIN+STACKWIDTH*3,x
	jsr NEXTSEGMENTS

; optimize OK (snowflake.pas), line = 93

	lda C.X
	sta MOVETO2D.AX
	lda C.X+1
	sta MOVETO2D.AX+1
	lda C.X+2
	sta MOVETO2D.AX+2
	lda C.X+3
	sta MOVETO2D.AX+3
	lda C.Y
	sta MOVETO2D.AY
	lda C.Y+1
	sta MOVETO2D.AY+1
	lda C.Y+2
	sta MOVETO2D.AY+2
	lda C.Y+3
	sta MOVETO2D.AY+3
	jsr MOVETO2D

; optimize OK (snowflake.pas), line = 94

	lda A.X
	sta LINETO2D.AX
	lda A.X+1
	sta LINETO2D.AX+1
	lda A.X+2
	sta LINETO2D.AX+2
	lda A.X+3
	sta LINETO2D.AX+3
	lda A.Y
	sta LINETO2D.AY
	lda A.Y+1
	sta LINETO2D.AY+1
	lda A.Y+2
	sta LINETO2D.AY+2
	lda A.Y+3
	sta LINETO2D.AY+3
	jsr LINETO2D

; optimize FAIL ('NEXTSEGMENTS', snowflake.pas), line = 95

	inx
	mva N :STACKORIGIN,x
	inx
	mva A.Y :STACKORIGIN,x
	mva A.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva A.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva A.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva A.X :STACKORIGIN,x
	mva A.X+1 :STACKORIGIN+STACKWIDTH,x
	mva A.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva A.X+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva C.Y :STACKORIGIN,x
	mva C.Y+1 :STACKORIGIN+STACKWIDTH,x
	mva C.Y+2 :STACKORIGIN+STACKWIDTH*2,x
	mva C.Y+3 :STACKORIGIN+STACKWIDTH*3,x
	inx
	mva C.X :STACKORIGIN,x
	mva C.X+1 :STACKORIGIN+STACKWIDTH,x
	mva C.X+2 :STACKORIGIN+STACKWIDTH*2,x
	mva C.X+3 :STACKORIGIN+STACKWIDTH*3,x
	jsr NEXTSEGMENTS

; ------------------------------------------------------------

adr.A	= DATAORIGIN+$0084	; [8] RECORD
.var A	= adr.A .word
A.X	= DATAORIGIN+$0084
A.Y	= DATAORIGIN+$0088
adr.B	= DATAORIGIN+$008C	; [8] RECORD
.var B	= adr.B .word
B.X	= DATAORIGIN+$008C
B.Y	= DATAORIGIN+$0090
adr.C	= DATAORIGIN+$0094	; [8] RECORD
.var C	= adr.C .word
C.X	= DATAORIGIN+$0094
C.Y	= DATAORIGIN+$0098
N	= DATAORIGIN+$009C

@VarData	= A.X
@VarDataSize	= 25

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CREATEKOCHSNOWFLAKE				; PROCEDURE

; optimize OK (snowflake.pas), line = 103

	lda #$00
	sta A.X
	lda #$BA
	sta A.X+1
	lda #$FF
	sta A.X+2
	sta A.X+3

; optimize OK (snowflake.pas), line = 104

	lda #$61
	sta A.Y
	lda #$C3
	sta A.Y+1
	lda #$FF
	sta A.Y+2
	sta A.Y+3

; optimize OK (snowflake.pas), line = 105

	lda #$00
	sta B.X
	lda #$46
	sta B.X+1
	lda #$00
	sta B.X+2
	sta B.X+3

; optimize OK (snowflake.pas), line = 106

	lda #$61
	sta B.Y
	lda #$C3
	sta B.Y+1
	lda #$FF
	sta B.Y+2
	sta B.Y+3

; optimize OK (snowflake.pas), line = 107

	lda #$00
	sta C.X
	sta C.X+1
	sta C.X+2
	sta C.X+3

; optimize OK (snowflake.pas), line = 108

	lda #$9F
	sta C.Y
	lda #$3C
	sta C.Y+1
	lda #$00
	sta C.Y+2
	sta C.Y+3

; optimize FAIL ('KOCHSNOWFLAKE', snowflake.pas), line = 109

	inx
	mva #$03 :STACKORIGIN,x
	inx
	mva C :STACKORIGIN,x
	mva C+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva B :STACKORIGIN,x
	mva B+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva A :STACKORIGIN,x
	mva A+1 :STACKORIGIN+STACKWIDTH,x
	jsr KOCHSNOWFLAKE

; ------------------------------------------------------------

adr.A	= DATAORIGIN+$009D	; [8] RECORD
.var A	= adr.A .word
A.X	= DATAORIGIN+$009D
A.Y	= DATAORIGIN+$00A1
adr.B	= DATAORIGIN+$00A5	; [8] RECORD
.var B	= adr.B .word
B.X	= DATAORIGIN+$00A5
B.Y	= DATAORIGIN+$00A9
adr.C	= DATAORIGIN+$00AD	; [8] RECORD
.var C	= adr.C .word
C.X	= DATAORIGIN+$00AD
C.Y	= DATAORIGIN+$00B1

@VarData	= A.X
@VarDataSize	= 24

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_0004

; optimize OK (snowflake.pas), line = 114

	lda #$00
	jsr GRAPH.INITGRAPH.@0097

; optimize FAIL ('CREATEKOCHSNOWFLAKE', snowflake.pas), line = 115

	jsr CREATEKOCHSNOWFLAKE

; --- RepeatUntilProlog
l_0285

; optimize FAIL ('CRT.KEYPRESSED', snowflake.pas), line = 116

	jsr CRT.KEYPRESSED
	lda CRT.KEYPRESSED.RESULT
	jeq l_0285

; ------------------------------------------------------------

GD	= DATAORIGIN+$0037
GM	= DATAORIGIN+$0039
CX	= $A0
CY	= $64
RAY0	= $4600
RAY1	= $2300
SQRT3	= $01BB
ITERATION	= $03
@exit

@halt	ldx #$00
	txs

	rts

; ------------------------------------------------------------

; ------------------------------------------------------------

.local	@DEFINES
NEO
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi

	.ifdef MAIN.TYPES.@UnitInit
	jsr MAIN.TYPES.@UnitInit
	.fi

	.ifdef MAIN.GRAPH.@UnitInit
	jsr MAIN.GRAPH.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

	ift .SIZEOF(MAIN.TYPES) > 0
	.print 'TYPES: ',MAIN.TYPES,'..',MAIN.TYPES+.SIZEOF(MAIN.TYPES)-1
	eif

	ift .SIZEOF(MAIN.GRAPH) > 0
	.print 'GRAPH: ',MAIN.GRAPH,'..',MAIN.GRAPH+.SIZEOF(MAIN.GRAPH)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $00 $27 $00  $00 $00 $17

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 181

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

; ------------------------------------------------------------

.macro	STATICDATA
.endm

	end
