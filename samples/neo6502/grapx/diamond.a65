; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.1 [2024/01/31] for 6502
; ------------------------------------------------------------

STACKWIDTH	= 16

TRUE		= 1
FALSE		= 0

; ------------------------------------------------------------

	org $00

zpage

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

; ------------------------------------------------------------

	opt h-f+c+

	org $5000
	jmp START

CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_neo.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift VADR > $BFFF
	ert 'Invalid memory address range ',VADR
	eli (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00
	stx bp						; BP = 0

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_0004

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
DATESEPARATOR	= DATAORIGIN+$0004
FILEMODE	= DATAORIGIN+$0005
GRAPHMODE	= DATAORIGIN+$0006
IORESULT	= DATAORIGIN+$0007
EOLN	= DATAORIGIN+$0008
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	TYPES						; UNIT

; ------------------------------------------------------------

.endl							; UNIT TYPES

; ------------------------------------------------------------

.local	GRAPH						; UNIT

.local	INITGRAPH					; PROCEDURE | OVERLOAD
.local	@0096
	sta MODE

; optimize OK (graph_neo.inc), line = 9

	lda #$40
	sta SYSTEM.SCREENWIDTH
	lda #$01
	sta SYSTEM.SCREENWIDTH+1

; optimize OK (graph_neo.inc), line = 10

	lda #$F0
	sta SYSTEM.SCREENHEIGHT
	lda #$00
	sta SYSTEM.SCREENHEIGHT+1

; -------------------  ASM Block 00000059  -------------------

	    @ClrScr
	
; ------------------------------------------------------------

MODE	= DATAORIGIN+$002C

@VarData	= MODE
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	SETCOLOR					; PROCEDURE | ASSEMBLER
	sta COLOR

; -------------------  ASM Block 00000061  -------------------

    lda #0
    sta	DParameters
    sta DParameters+2
    sta DParameters+3
    sta DParameters+4
    lda color
    sta DParameters+1
    @SendMessage 				
	.byte 	5,1

; ------------------------------------------------------------

COLOR	= DATAORIGIN+$002D

@VarData	= COLOR
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	LINETO						; PROCEDURE

; -------------------  ASM Block 00000065  -------------------

        mwa CurrentX DParameters
        mwa CurrentY DParameters+2
        mwa x DParameters+4
        mwa y DParameters+6
        @SendMessage 				
        .byte 	5,2
    
; optimize OK (graph_neo.inc), line = 127

	lda X
	sta CURRENTX
	lda X+1
	sta CURRENTX+1

; optimize OK (graph_neo.inc), line = 128

	lda Y
	sta CURRENTY
	lda Y+1
	sta CURRENTY+1

; ------------------------------------------------------------

X	= DATAORIGIN+$002E
Y	= DATAORIGIN+$0030

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOVETO						; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000067  -------------------

	lda y+1
	bpl _0

	lda #0
	sta y
	sta y+1
_0
	lda x+1
	bpl _1

	lda #0
	sta x
	sta x+1
_1
	cpw y main.system.ScreenHeight
	bcc _2

	sbw main.system.ScreenHeight #1 y
_2
	cpw x main.system.ScreenWidth
	bcc _3

	sbw main.system.ScreenWidth #1 x
_3
	mwa x CurrentX
	mwa y CurrentY


; ------------------------------------------------------------

X	= DATAORIGIN+$0032
Y	= DATAORIGIN+$0034

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

CURRENTDRIVER	= $80
DETECT	= $00
CGA	= $01
MCGA	= $02
EGA	= $03
EGA64	= $04
EGAMONO	= $05
LOWRES	= $06
HERCMONO	= $07
VGA	= $09
VESA	= $0A
D1BIT	= $0B
D2BIT	= $0C
D4BIT	= $0D
D6BIT	= $0E
D8BIT	= $0F
D12BIT	= $10
M640X400	= $18
M640X480	= $18
GROK	= $01
GRNOINITGRAPH	= $FF
GRNOTDETECTED	= $FE
GRFILENOTFOUND	= $FD
GRINVALIDDRIVER	= $FC
GRNOLOADMEM	= $FB
GRNOSCANMEM	= $FA
GRNOFLOODMEM	= $F9
GRFONTNOTFOUND	= $F8
GRNOFONTMEM	= $F7
GRINVALIDMODE	= $F6
GRERROR	= $F5
GRIOERROR	= $F4
GRINVALIDFONT	= $F3
GRINVALIDFONTNUM	= $F2
GRINVALIDVERSION	= $EE
CGAC0	= $00
CGAC1	= $01
CGAC2	= $02
CGAC3	= $03
CGAHI	= $04
MCGAC0	= $00
MCGAC1	= $01
MCGAC2	= $02
MCGAC3	= $03
MCGAMED	= $04
MCGAHI	= $05
EGALO	= $00
EGAHI	= $01
EGA64LO	= $00
EGA64HI	= $01
EGAMONOHI	= $03
VGALO	= $0A
VGAMED	= $1F
VGAHI	= $18
WIN_LEFT	= DATAORIGIN+$000B
WIN_RIGHT	= DATAORIGIN+$000D
WIN_TOP	= DATAORIGIN+$000F
WIN_BOTTOM	= DATAORIGIN+$0011
GRAPHRESULT	= DATAORIGIN+$0013
GETCOLOR	= DATAORIGIN+$0014
VIDEORAM	= DATAORIGIN+$0015
adr.LASTARCCOORDS	= DATAORIGIN+$0017	; [12] RECORD
.var LASTARCCOORDS	= adr.LASTARCCOORDS .word
LASTARCCOORDS.X	= DATAORIGIN+$0017
LASTARCCOORDS.Y	= DATAORIGIN+$0019
LASTARCCOORDS.XSTART	= DATAORIGIN+$001B
LASTARCCOORDS.YSTART	= DATAORIGIN+$001D
LASTARCCOORDS.XEND	= DATAORIGIN+$001F
LASTARCCOORDS.YEND	= DATAORIGIN+$0021
SCANLINE_WIDTH	= DATAORIGIN+$0023
CURRENTX	= DATAORIGIN+$0024
CURRENTY	= DATAORIGIN+$0026
LINEX	= DATAORIGIN+$0028
LINEY	= DATAORIGIN+$002A

.endl							; UNIT GRAPH

; ------------------------------------------------------------

.local	CRT						; UNIT

.local	CLRSCR						; PROCEDURE

; -------------------  ASM Block 00000068  -------------------

	@ClrScr
	
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	KEYPRESSED					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000073  -------------------

	@SendMessage
	dta 2,2
	@WaitMessage
	lda DParameters
	sta result

@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0036
	rts						; ret
.endl

; ------------------------------------------------------------

BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLINK	= $80

.endl							; UNIT CRT

.local	DRAW						; PROCEDURE
	.ifdef @VarData
@new	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jsr @AllocMem
	eif

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta X
	lda :STACKORIGIN+STACKWIDTH,x
	sta X+1
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta Y
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta S
	dex
@main

; optimize OK (diamond.pas), line = 8

	lda COL
	jsr GRAPH.SETCOLOR

; optimize OK (diamond.pas), line = 9

	lda S
	cmp #$02
	jcc l_0138

; optimize OK (diamond.pas), line = 11

	lsr S

; optimize OK (diamond.pas), line = 12

	lda Y
	add S
	sta GRAPH.MOVETO.Y
	lda #$00
	adc #$00
	sta GRAPH.MOVETO.Y+1
	lda X
	sta GRAPH.MOVETO.X
	lda X+1
	sta GRAPH.MOVETO.X+1
	jsr GRAPH.MOVETO

; optimize OK (diamond.pas), line = 13

	lda X
	add S
	sta GRAPH.LINETO.X
	lda X+1
	adc #$00
	sta GRAPH.LINETO.X+1
	lda Y
	sta GRAPH.LINETO.Y
	lda #$00
	sta GRAPH.LINETO.Y+1
	jsr GRAPH.LINETO

; optimize OK (diamond.pas), line = 14

	lda Y
	sub S
	sta GRAPH.LINETO.Y
	lda #$00
	sbc #$00
	sta GRAPH.LINETO.Y+1
	lda X
	sta GRAPH.LINETO.X
	lda X+1
	sta GRAPH.LINETO.X+1
	jsr GRAPH.LINETO

; optimize OK (diamond.pas), line = 15

	lda X
	sub S
	sta GRAPH.LINETO.X
	lda X+1
	sbc #$00
	sta GRAPH.LINETO.X+1
	lda Y
	sta GRAPH.LINETO.Y
	lda #$00
	sta GRAPH.LINETO.Y+1
	jsr GRAPH.LINETO

; optimize OK (diamond.pas), line = 16

	lda Y
	add S
	sta GRAPH.LINETO.Y
	lda #$00
	adc #$00
	sta GRAPH.LINETO.Y+1
	lda X
	sta GRAPH.LINETO.X
	lda X+1
	sta GRAPH.LINETO.X+1
	jsr GRAPH.LINETO

; optimize FAIL ('DRAW', diamond.pas), line = 17

	inx
	mva S :STACKORIGIN,x
	inx
	mva Y :STACKORIGIN,x
	inx
	lda X
	add S
	sta :STACKORIGIN,x
	lda X+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH,x
	jsr DRAW

; optimize FAIL ('DRAW', diamond.pas), line = 18

	inx
	mva S :STACKORIGIN,x
	inx
	mva Y :STACKORIGIN,x
	inx
	lda X
	sub S
	sta :STACKORIGIN,x
	lda X+1
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH,x
	jsr DRAW

; optimize FAIL ('DRAW', diamond.pas), line = 19

	inx
	mva S :STACKORIGIN,x
	inx
	lda Y
	sub S
	sta :STACKORIGIN,x
	inx
	mva X :STACKORIGIN,x
	mva X+1 :STACKORIGIN+STACKWIDTH,x
	jsr DRAW

; optimize FAIL ('DRAW', diamond.pas), line = 20

	inx
	mva S :STACKORIGIN,x
	inx
	lda Y
	add S
	sta :STACKORIGIN,x
	inx
	mva X :STACKORIGIN,x
	mva X+1 :STACKORIGIN+STACKWIDTH,x
	jsr DRAW
l_0138

; optimize OK (diamond.pas), line = 22

	lda COL
	add #$01
	and #$0F
	sta COL

; ------------------------------------------------------------

X	= DATAORIGIN+$0038
Y	= DATAORIGIN+$003A
S	= DATAORIGIN+$003B

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_0004

; optimize OK (diamond.pas), line = 26

	lda #$00
	jsr GRAPH.INITGRAPH.@0096

; optimize OK (diamond.pas), line = 27

	lda #$01
	sta COL

; optimize FAIL ('DRAW', diamond.pas), line = 28

	inx
	mva SYSTEM.SCREENHEIGHT :STACKORIGIN,x
	mva SYSTEM.SCREENHEIGHT+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$01 :STACKORIGIN,x
	jsr @expandToCARD1.SMALL
	jsr shrEAX_CL
	mva SYSTEM.SCREENHEIGHT :STACKORIGIN,x
	mva SYSTEM.SCREENHEIGHT+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$01 :STACKORIGIN,x
	jsr @expandToCARD1.SMALL
	jsr shrEAX_CL
	mva SYSTEM.SCREENWIDTH :STACKORIGIN,x
	mva SYSTEM.SCREENWIDTH+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$01 :STACKORIGIN,x
	jsr @expandToCARD1.SMALL
	jsr shrEAX_CL
	dex
	jsr DRAW

; --- RepeatUntilProlog
l_01E6

; optimize FAIL ('CRT.KEYPRESSED', diamond.pas), line = 29

	jsr CRT.KEYPRESSED
	lda CRT.KEYPRESSED.RESULT
	jeq l_01E6

; optimize FAIL ('CRT.CLRSCR', diamond.pas), line = 30

	jsr CRT.CLRSCR

; -------------------  ASM Block 00000080  -------------------

 jmp $800 
; ------------------------------------------------------------

M	= $02
COL	= DATAORIGIN+$0037
@exit

@halt	ldx #$00
	txs

	rts

; ------------------------------------------------------------

; ------------------------------------------------------------

.local	@DEFINES
NEO
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.TYPES.@UnitInit
	jsr MAIN.TYPES.@UnitInit
	.fi

	.ifdef MAIN.GRAPH.@UnitInit
	jsr MAIN.GRAPH.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.TYPES) > 0
	.print 'TYPES: ',MAIN.TYPES,'..',MAIN.TYPES+.SIZEOF(MAIN.TYPES)-1
	eif

	ift .SIZEOF(MAIN.GRAPH) > 0
	.print 'GRAPH: ',MAIN.GRAPH,'..',MAIN.GRAPH+.SIZEOF(MAIN.GRAPH)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $27 $00 $00  $00 $17

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 60

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

; ------------------------------------------------------------

.macro	STATICDATA
.endm

	end
