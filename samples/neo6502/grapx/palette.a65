; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.1 [2024/02/04] for 6502
; ------------------------------------------------------------

STACKWIDTH	= 16

TRUE		= 1
FALSE		= 0

; ------------------------------------------------------------

	org $00

zpage

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

; ------------------------------------------------------------

	opt h-f+c+

	org $8000
	jmp START

CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_neo.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift VADR > $BFFF
	ert 'Invalid memory address range ',VADR
	eli (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00
	stx bp						; BP = 0

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_0004

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
DATESEPARATOR	= DATAORIGIN+$0004
FILEMODE	= DATAORIGIN+$0005
GRAPHMODE	= DATAORIGIN+$0006
IORESULT	= DATAORIGIN+$0007
EOLN	= DATAORIGIN+$0008
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	NEO6502						; UNIT

.local	NEOWAITMESSAGE					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000059  -------------------

   @WaitMessage 

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	NEOSENDMESSAGE					; FUNCTION

; optimize FAIL ('NEOWAITMESSAGE', NEO6502), line = 442

	jsr NEOWAITMESSAGE

; optimize OK (NEO6502), line = 443

	lda FUNC
	sta NEOMESSAGE.FUNC

; optimize OK (NEO6502), line = 444

	lda GROUP
	sta NEOMESSAGE.GROUP

; --- RepeatUntilProlog
l_0093

; optimize OK (NEO6502), line = 445

	lda NEOMESSAGE.GROUP
	jne l_0093

; optimize OK (NEO6502), line = 446

	lda adr.NEOMESSAGE.PARAMS
	sta RESULT
@exit

; ------------------------------------------------------------

GROUP	= DATAORIGIN+$000B
FUNC	= DATAORIGIN+$000C
RESULT	= DATAORIGIN+$000D

@VarData	= GROUP
@VarDataSize	= 2

	rts						; ret
.endl

.local	NEOSETCOLOR					; PROCEDURE

; optimize OK (NEO6502), line = 563

	lda ACOL
	sta adr.NEOMESSAGE.PARAMS

; optimize OK (NEO6502), line = 564

	lda XCOL
	sta adr.NEOMESSAGE.PARAMS+$01

; optimize OK (NEO6502), line = 565

	lda SOLID
	sta adr.NEOMESSAGE.PARAMS+$02

; optimize OK (NEO6502), line = 566

	lda SIZE
	sta adr.NEOMESSAGE.PARAMS+$03

; optimize OK (NEO6502), line = 567

	lda FLIP
	sta adr.NEOMESSAGE.PARAMS+$04

; optimize OK (NEO6502), line = 568

	lda #$05
	sta NEOSENDMESSAGE.GROUP
	lda #$01
	sta NEOSENDMESSAGE.FUNC
	jsr NEOSENDMESSAGE

; ------------------------------------------------------------

ACOL	= DATAORIGIN+$000E
XCOL	= DATAORIGIN+$000F
SOLID	= DATAORIGIN+$0010
SIZE	= DATAORIGIN+$0011
FLIP	= DATAORIGIN+$0012

@VarData	= ACOL
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	NEODRAWRECT					; PROCEDURE

; optimize OK (NEO6502), line = 582

	lda X0
	sta adr.WORDPARAMS
	lda X0+1
	sta adr.WORDPARAMS+1

; optimize OK (NEO6502), line = 583

	lda Y0
	sta adr.WORDPARAMS+$02
	lda Y0+1
	sta adr.WORDPARAMS+1+$02

; optimize OK (NEO6502), line = 584

	lda X1
	sta adr.WORDPARAMS+$04
	lda X1+1
	sta adr.WORDPARAMS+1+$04

; optimize OK (NEO6502), line = 585

	lda Y1
	sta adr.WORDPARAMS+$06
	lda Y1+1
	sta adr.WORDPARAMS+1+$06

; optimize OK (NEO6502), line = 586

	lda #$05
	sta NEOSENDMESSAGE.GROUP
	lda #$03
	sta NEOSENDMESSAGE.FUNC
	jsr NEOSENDMESSAGE

; ------------------------------------------------------------

X0	= DATAORIGIN+$0013
Y0	= DATAORIGIN+$0015
X1	= DATAORIGIN+$0017
Y1	= DATAORIGIN+$0019

@VarData	= X0
@VarDataSize	= 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	NEOSETPALETTE					; PROCEDURE

; optimize OK (NEO6502), line = 632

	lda COL
	sta adr.NEOMESSAGE.PARAMS

; optimize OK (NEO6502), line = 633

	lda R
	sta adr.NEOMESSAGE.PARAMS+$01

; optimize OK (NEO6502), line = 634

	lda G
	sta adr.NEOMESSAGE.PARAMS+$02

; optimize OK (NEO6502), line = 635

	lda B
	sta adr.NEOMESSAGE.PARAMS+$03

; optimize OK (NEO6502), line = 636

	lda #$05
	sta NEOSENDMESSAGE.GROUP
	lda #$20
	sta NEOSENDMESSAGE.FUNC
	jsr NEOSENDMESSAGE

; ------------------------------------------------------------

COL	= DATAORIGIN+$001B
R	= DATAORIGIN+$001C
G	= DATAORIGIN+$001D
B	= DATAORIGIN+$001E

@VarData	= COL
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

N6502MSG_ADDRESS	= $FF00
NEO_GFX_RAM	= $FFFF
adr.NEOMESSAGE	= $FF00
.var NEOMESSAGE	= adr.NEOMESSAGE .word
NEOMESSAGE.GROUP	= $FF00
NEOMESSAGE.FUNC	= $FF01
NEOMESSAGE.ERROR	= $FF02
NEOMESSAGE.STATUS	= $FF03
adr.NEOMESSAGE.PARAMS	= $FF04
.var NEOMESSAGE.PARAMS	= adr.NEOMESSAGE.PARAMS .word
adr.WORDPARAMS	= $FF04
.var WORDPARAMS	= adr.WORDPARAMS .word
adr.DWORDPARAMS	= $FF04
.var DWORDPARAMS	= adr.DWORDPARAMS .word
adr.WORDXPARAMS	= $FF05
.var WORDXPARAMS	= adr.WORDXPARAMS .word
adr.SOUNDPARAMS	= $FF04
.var SOUNDPARAMS	= adr.SOUNDPARAMS .word
SOUNDPARAMS.CHANNEL	= $FF04
SOUNDPARAMS.FREQ	= $FF05
SOUNDPARAMS.LEN	= $FF07
SOUNDPARAMS.SLIDE	= $FF09
SOUNDPARAMS.STYPE	= $FF0B

.endl							; UNIT NEO6502

; ------------------------------------------------------------

.local	CRT						; UNIT

.local	KEYPRESSED					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000065  -------------------

	@SendMessage
	dta 2,2
	@WaitMessage
	lda DParameters
	sta result

@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$001F
	rts						; ret
.endl

; ------------------------------------------------------------

BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLINK	= $80

.endl							; UNIT CRT

.local	HSVTORGB					; PROCEDURE

; optimize OK (palette.pas), line = 18

	lda H+3
	bne @+
	lda H+2
	cmp #$01
	bne @+
	lda H+1
	cmp #$68
	bne @+
	lda H
@
	jne l_0128

; optimize OK (palette.pas), line = 19

	lda #$00
	sta H
	sta H+1
	sta H+2
	sta H+3
l_0128

; optimize OK (palette.pas), line = 20

	lda #$00
	sta @REAL_DIV.B
	lda #$3C
	sta @REAL_DIV.B+1
	lda #$00
	sta @REAL_DIV.B+2
	sta @REAL_DIV.B+3
	lda H
	sta @REAL_DIV.A
	lda H+1
	sta @REAL_DIV.A+1
	lda H+2
	sta @REAL_DIV.A+2
	lda H+3
	sta @REAL_DIV.A+3
	jsr @REAL_DIV
	lda :eax
	sta H
	lda :eax+1
	sta H+1
	lda :eax+2
	sta H+2
	lda :eax+3
	sta H+3

; optimize OK (palette.pas), line = 21

	lda H
	sta @REAL_TRUNC.A
	lda H+1
	sta @REAL_TRUNC.A+1
	lda H+2
	sta @REAL_TRUNC.A+2
	lda H+3
	sta @REAL_TRUNC.A+3
	jsr @REAL_TRUNC
	lda :eax
	sta I

; optimize OK (palette.pas), line = 22

	lda H
	sta F
	lda H+1
	sub I
	sta F+1
	lda H+2
	sbc #$00
	sta F+2
	lda H+3
	sbc #$00
	sta F+3

; optimize OK (palette.pas), line = 23

	lda #$00
	sub S
	sta @REAL_MUL.B
	lda #$01
	sbc S+1
	sta @REAL_MUL.B+1
	lda #$00
	sbc S+2
	sta @REAL_MUL.B+2
	lda #$00
	sbc S+3
	sta @REAL_MUL.B+3
	lda V
	sta @REAL_MUL.A
	lda V+1
	sta @REAL_MUL.A+1
	lda V+2
	sta @REAL_MUL.A+2
	lda V+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda :eax
	sta P1
	lda :eax+1
	sta P1+1
	lda :eax+2
	sta P1+2
	lda :eax+3
	sta P1+3

; optimize OK (palette.pas), line = 24

	lda F
	sta @REAL_MUL.B
	lda F+1
	sta @REAL_MUL.B+1
	lda F+2
	sta @REAL_MUL.B+2
	lda F+3
	sta @REAL_MUL.B+3
	lda S
	sta @REAL_MUL.A
	lda S+1
	sta @REAL_MUL.A+1
	lda S+2
	sta @REAL_MUL.A+2
	lda S+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda #$00
	sub :eax
	sta @REAL_MUL.B
	lda #$01
	sbc :eax+1
	sta @REAL_MUL.B+1
	lda #$00
	sbc :eax+2
	sta @REAL_MUL.B+2
	lda #$00
	sbc :eax+3
	sta @REAL_MUL.B+3
	lda V
	sta @REAL_MUL.A
	lda V+1
	sta @REAL_MUL.A+1
	lda V+2
	sta @REAL_MUL.A+2
	lda V+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda :eax
	sta P2
	lda :eax+1
	sta P2+1
	lda :eax+2
	sta P2+2
	lda :eax+3
	sta P2+3

; optimize OK (palette.pas), line = 25

	lda #$00
	sub F
	sta @REAL_MUL.B
	lda #$01
	sbc F+1
	sta @REAL_MUL.B+1
	lda #$00
	sbc F+2
	sta @REAL_MUL.B+2
	lda #$00
	sbc F+3
	sta @REAL_MUL.B+3
	lda S
	sta @REAL_MUL.A
	lda S+1
	sta @REAL_MUL.A+1
	lda S+2
	sta @REAL_MUL.A+2
	lda S+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda #$00
	sub :eax
	sta @REAL_MUL.B
	lda #$01
	sbc :eax+1
	sta @REAL_MUL.B+1
	lda #$00
	sbc :eax+2
	sta @REAL_MUL.B+2
	lda #$00
	sbc :eax+3
	sta @REAL_MUL.B+3
	lda V
	sta @REAL_MUL.A
	lda V+1
	sta @REAL_MUL.A+1
	lda V+2
	sta @REAL_MUL.A+2
	lda V+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	lda :eax
	sta P3
	lda :eax+1
	sta P3+1
	lda :eax+2
	sta P3+2
	lda :eax+3
	sta P3+3

; optimize OK (palette.pas), line = 26

	lda I
	sta @CASETMP_0004
	jne l_0180
@

; optimize OK (palette.pas), line = 29

	lda V
	sta R
	lda V+1
	sta R+1
	lda V+2
	sta R+2
	lda V+3
	sta R+3

; optimize OK (palette.pas), line = 30

	lda P3
	sta G
	lda P3+1
	sta G+1
	lda P3+2
	sta G+2
	lda P3+3
	sta G+3

; optimize OK (palette.pas), line = 31

	lda P1
	sta B
	lda P1+1
	sta B+1
	lda P1+2
	sta B+2
	lda P1+3
	sta B+3
	jmp a_0004
l_0180
	cmp #$01
	jne l_0193

; optimize OK (palette.pas), line = 35

	lda P2
	sta R
	lda P2+1
	sta R+1
	lda P2+2
	sta R+2
	lda P2+3
	sta R+3

; optimize OK (palette.pas), line = 36

	lda V
	sta G
	lda V+1
	sta G+1
	lda V+2
	sta G+2
	lda V+3
	sta G+3

; optimize OK (palette.pas), line = 37

	lda P1
	sta B
	lda P1+1
	sta B+1
	lda P1+2
	sta B+2
	lda P1+3
	sta B+3
	jmp a_0004
l_0193
	cmp #$02
	jne l_01A6

; optimize OK (palette.pas), line = 41

	lda P1
	sta R
	lda P1+1
	sta R+1
	lda P1+2
	sta R+2
	lda P1+3
	sta R+3

; optimize OK (palette.pas), line = 42

	lda V
	sta G
	lda V+1
	sta G+1
	lda V+2
	sta G+2
	lda V+3
	sta G+3

; optimize OK (palette.pas), line = 43

	lda P3
	sta B
	lda P3+1
	sta B+1
	lda P3+2
	sta B+2
	lda P3+3
	sta B+3
	jmp a_0004
l_01A6
	cmp #$03
	jne l_01B9

; optimize OK (palette.pas), line = 47

	lda P1
	sta R
	lda P1+1
	sta R+1
	lda P1+2
	sta R+2
	lda P1+3
	sta R+3

; optimize OK (palette.pas), line = 48

	lda P2
	sta G
	lda P2+1
	sta G+1
	lda P2+2
	sta G+2
	lda P2+3
	sta G+3

; optimize OK (palette.pas), line = 49

	lda V
	sta B
	lda V+1
	sta B+1
	lda V+2
	sta B+2
	lda V+3
	sta B+3
	jmp a_0004
l_01B9
	cmp #$04
	jne l_01CC

; optimize OK (palette.pas), line = 53

	lda P3
	sta R
	lda P3+1
	sta R+1
	lda P3+2
	sta R+2
	lda P3+3
	sta R+3

; optimize OK (palette.pas), line = 54

	lda P1
	sta G
	lda P1+1
	sta G+1
	lda P1+2
	sta G+2
	lda P1+3
	sta G+3

; optimize OK (palette.pas), line = 55

	lda V
	sta B
	lda V+1
	sta B+1
	lda V+2
	sta B+2
	lda V+3
	sta B+3
	jmp a_0004
l_01CC
	cmp #$05
	jne l_01DF

; optimize OK (palette.pas), line = 59

	lda V
	sta R
	lda V+1
	sta R+1
	lda V+2
	sta R+2
	lda V+3
	sta R+3

; optimize OK (palette.pas), line = 60

	lda P1
	sta G
	lda P1+1
	sta G+1
	lda P1+2
	sta G+2
	lda P1+3
	sta G+3

; optimize OK (palette.pas), line = 61

	lda P2
	sta B
	lda P2+1
	sta B+1
	lda P2+2
	sta B+2
	lda P2+3
	sta B+3
l_01DF
a_0004

; optimize OK (palette.pas), line = 67

	lda #$00
	sta @REAL_MUL.B
	sta @REAL_MUL.B+1
	lda #$01
	sta @REAL_MUL.B+2
	lda #$00
	sta @REAL_MUL.B+3
	lda R
	sta @REAL_MUL.A
	lda R+1
	sta @REAL_MUL.A+1
	lda R+2
	sta @REAL_MUL.A+2
	lda R+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	jsr @REAL_ROUND
	lda :eax
	sta RB

; optimize OK (palette.pas), line = 68

	lda #$00
	sta @REAL_MUL.B
	sta @REAL_MUL.B+1
	lda #$01
	sta @REAL_MUL.B+2
	lda #$00
	sta @REAL_MUL.B+3
	lda G
	sta @REAL_MUL.A
	lda G+1
	sta @REAL_MUL.A+1
	lda G+2
	sta @REAL_MUL.A+2
	lda G+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	jsr @REAL_ROUND
	lda :eax
	sta GB

; optimize OK (palette.pas), line = 69

	lda #$00
	sta @REAL_MUL.B
	sta @REAL_MUL.B+1
	lda #$01
	sta @REAL_MUL.B+2
	lda #$00
	sta @REAL_MUL.B+3
	lda B
	sta @REAL_MUL.A
	lda B+1
	sta @REAL_MUL.A+1
	lda B+2
	sta @REAL_MUL.A+2
	lda B+3
	sta @REAL_MUL.A+3
	jsr @REAL_MUL
	jsr @REAL_ROUND
	lda :eax
	sta BB

; ------------------------------------------------------------

H	= DATAORIGIN+$0035
S	= DATAORIGIN+$0039
V	= DATAORIGIN+$003D
R	= DATAORIGIN+$0041
G	= DATAORIGIN+$0045
B	= DATAORIGIN+$0049
P1	= DATAORIGIN+$004D
P2	= DATAORIGIN+$0051
P3	= DATAORIGIN+$0055
F	= DATAORIGIN+$0059
I	= DATAORIGIN+$005D
@CASETMP_0004	= DATAORIGIN+$005E

@VarData	= H
@VarDataSize	= 42

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_0004

; optimize OK (palette.pas), line = 73

	lda #$00
	sta C

; optimize OK (palette.pas), line = 74

	sta I

l_0219
; --- ForToDoCondition
	lda I
	cmp #$10
	jcs l_0227

; optimize OK (palette.pas), line = 75

	lda #$00
	sta J

l_0230
; --- ForToDoCondition
	lda J
	cmp #$10
	jcs l_023E

; optimize OK (palette.pas), line = 76

	sta :ecx
	lda #$14
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	sta X+1
	lda :eax
	sta X

; optimize OK (palette.pas), line = 77

	lda I
	sta :ecx
	lda #$0F
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta Y

; optimize OK (palette.pas), line = 78

	lda #$00
	sta NEO6502.NEOSETCOLOR.ACOL
	lda C
	sta NEO6502.NEOSETCOLOR.XCOL
	lda #$01
	sta NEO6502.NEOSETCOLOR.SOLID
	sta NEO6502.NEOSETCOLOR.SIZE
	lda #$00
	sta NEO6502.NEOSETCOLOR.FLIP
	jsr NEO6502.NEOSETCOLOR

; optimize OK (palette.pas), line = 79

	lda Y
	add #$0F
	sta NEO6502.NEODRAWRECT.Y1
	lda #$00
	adc #$00
	sta NEO6502.NEODRAWRECT.Y1+1
	lda X
	add #$14
	sta NEO6502.NEODRAWRECT.X1
	lda X+1
	adc #$00
	sta NEO6502.NEODRAWRECT.X1+1
	lda X
	sta NEO6502.NEODRAWRECT.X0
	lda X+1
	sta NEO6502.NEODRAWRECT.X0+1
	lda Y
	sta NEO6502.NEODRAWRECT.Y0
	lda #$00
	sta NEO6502.NEODRAWRECT.Y0+1
	jsr NEO6502.NEODRAWRECT

; optimize OK (palette.pas), line = 80

	lda I
	jeq l_027F

; optimize OK (palette.pas), line = 81

	lda #$00
	sta @REAL_MUL.A
	lda I
	sub #$01
	sta @REAL_MUL.A+1
	lda #$00
	sbc #$00
	sta @REAL_MUL.A+2
	lda #$00
	sbc #$00
	sta @REAL_MUL.A+3
	lda #$00
	sta @REAL_MUL.B
	lda #$18
	sta @REAL_MUL.B+1
	lda #$00
	sta @REAL_MUL.B+2
	sta @REAL_MUL.B+3
	jsr @REAL_MUL
	lda :eax
	sta H
	lda :eax+1
	sta H+1
	lda :eax+2
	sta H+2
	lda :eax+3
	sta H+3

; optimize OK (palette.pas), line = 82

	lda #$00
	sta @REAL_DIV.A+3
	sta @REAL_DIV.A+2
	lda J
	sta @REAL_DIV.A+1
	lda #$00
	sta @REAL_DIV.A
	sta @REAL_DIV.B
	lda #$10
	sta @REAL_DIV.B+1
	lda #$00
	sta @REAL_DIV.B+2
	sta @REAL_DIV.B+3
	jsr @REAL_DIV
	lda #$4D
	sta @REAL_MUL.B
	lda #$00
	sta @REAL_MUL.B+1
	sta @REAL_MUL.B+2
	sta @REAL_MUL.B+3
	jsr @REAL_MUL
	lda #$B3
	add :eax
	sta S
	lda #$00
	adc :eax+1
	sta S+1
	lda #$00
	adc :eax+2
	sta S+2
	lda #$00
	adc :eax+3
	sta S+3

; optimize OK (palette.pas), line = 83

	lda #$00
	sta @REAL_DIV.A+3
	sta @REAL_DIV.A+2
	lda J
	sta @REAL_DIV.A+1
	lda #$00
	sta @REAL_DIV.A
	sta @REAL_DIV.B
	lda #$10
	sta @REAL_DIV.B+1
	lda #$00
	sta @REAL_DIV.B+2
	sta @REAL_DIV.B+3
	jsr @REAL_DIV
	lda #$E6
	sta @REAL_MUL.B
	lda #$00
	sta @REAL_MUL.B+1
	sta @REAL_MUL.B+2
	sta @REAL_MUL.B+3
	jsr @REAL_MUL
	lda #$1A
	add :eax
	sta V
	lda #$00
	adc :eax+1
	sta V+1
	lda #$00
	adc :eax+2
	sta V+2
	lda #$00
	adc :eax+3
	sta V+3

; optimize OK (palette.pas), line = 84

	lda H
	sta HSVTORGB.H
	lda H+1
	sta HSVTORGB.H+1
	lda H+2
	sta HSVTORGB.H+2
	lda H+3
	sta HSVTORGB.H+3
	lda S
	sta HSVTORGB.S
	lda S+1
	sta HSVTORGB.S+1
	lda S+2
	sta HSVTORGB.S+2
	lda S+3
	sta HSVTORGB.S+3
	lda V
	sta HSVTORGB.V
	lda V+1
	sta HSVTORGB.V+1
	lda V+2
	sta HSVTORGB.V+2
	lda V+3
	sta HSVTORGB.V+3
	jsr HSVTORGB
	jmp l_02BF
l_027F

; optimize OK (palette.pas), line = 86

	lda J
	sta :ecx
	lda #$11
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta RB

; optimize OK (palette.pas), line = 87

	lda J
	sta :ecx
	lda #$11
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta GB

; optimize OK (palette.pas), line = 88

	lda J
	sta :ecx
	lda #$11
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta BB
l_02BF

; optimize OK (palette.pas), line = 90

	lda C
	sta NEO6502.NEOSETPALETTE.COL
	lda RB
	sta NEO6502.NEOSETPALETTE.R
	lda GB
	sta NEO6502.NEOSETPALETTE.G
	lda BB
	sta NEO6502.NEOSETPALETTE.B
	jsr NEO6502.NEOSETPALETTE

; optimize FAIL (0, palette.pas), line = 91

	inc C

; --- ForToDoEpilog
	inc J
	jne l_0230
l_023E

; --- ForToDoEpilog
	inc I
	jne l_0219
l_0227

; --- RepeatUntilProlog
l_02F9

; optimize FAIL ('CRT.KEYPRESSED', palette.pas), line = 95

	jsr CRT.KEYPRESSED
	lda CRT.KEYPRESSED.RESULT
	jeq l_02F9

; ------------------------------------------------------------

CELL_H	= $0F
CELL_W	= $14
Y	= DATAORIGIN+$0020
I	= DATAORIGIN+$0021
J	= DATAORIGIN+$0022
C	= DATAORIGIN+$0023
RB	= DATAORIGIN+$0024
GB	= DATAORIGIN+$0025
BB	= DATAORIGIN+$0026
X	= DATAORIGIN+$0027
H	= DATAORIGIN+$0029
S	= DATAORIGIN+$002D
V	= DATAORIGIN+$0031
@exit

@halt	ldx #$00
	txs

	rts

; ------------------------------------------------------------

; ------------------------------------------------------------

.local	@DEFINES
NEO
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.NEO6502.@UnitInit
	jsr MAIN.NEO6502.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.NEO6502) > 0
	.print 'NEO6502: ',MAIN.NEO6502,'..',MAIN.NEO6502+.SIZEOF(MAIN.NEO6502)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $28 $00 $18 $00 $2D $0C

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 95

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

; ------------------------------------------------------------

.macro	STATICDATA
.endm

	end
